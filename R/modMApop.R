#' Model-Assisted module - Generate population data for MA module.
#' 
#' Generates population data for generating model-assisted estimation.  Plots
#' that are totally nonsampled are excluded from estimation dataset. Next, an
#' adjustment factor is calculated by strata (if MAmethod="PS") or by
#' estimation unit to adjust for nonsampled (nonresponse) conditions that have
#' proportion less than 1. Attributes adjusted to a per-acre value are summed
#' by plot, divided by the adjustment factor, and averaged by stratum and/or
#' estimation unit. Note: population data must be generated by MA method.
#' 
#' If variables are NULL, then it will prompt user to input variables.
#' 
#' Necessary variables:\cr \tabular{llll}{ \tab \bold{Data} \tab
#' \bold{Variable} \tab \bold{Description}\cr \tab tree \tab tuniqueid \tab
#' Unique identifier for each plot, to link to pltassgn (ex. PLT_CN).\cr \tab
#' \tab CONDID \tab Unique identifier of each condition on plot, to link to
#' cond.  Set CONDID=1, if only 1 condition per plot.\cr \tab \tab TPA_UNADJ
#' \tab Number of trees per acre each sample tree represents (ex. DESIGNCD=1:
#' TPA_UNADJ=6.018046 for trees on subplot; 74.965282 for trees on
#' microplot).\cr \tab cond \tab cuniqueid \tab Unique identifier for each
#' plot, to link to pltassgn (ex. PLT_CN).\cr \tab \tab CONDID \tab Unique
#' identfier of each condition on plot.  Set CONDID=1, if only 1 condition per
#' plot.\cr \tab \tab CONDPROP_UNADJ \tab Unadjusted proportion of condition on
#' each plot.  Set CONDPROP_UNADJ=1, if only 1 condition per plot.\cr \tab \tab
#' COND_STATUS_CD \tab Status of each forested condition on plot (i.e.
#' accessible forest, nonforest, water, etc.)\cr \tab \tab NF_COND_STATUS_CD
#' \tab If ACI=TRUE. Status of each nonforest condition on plot (i.e.
#' accessible nonforest, nonsampled nonforest)\cr \tab \tab SITECLCD \tab If
#' landarea=TIMBERLAND. Measure of site productivity.\cr \tab \tab RESERVCD
#' \tab If landarea=TIMBERLAND. Reserved status.\cr \tab \tab SUBPROP_UNADJ
#' \tab Unadjusted proportion of subplot conditions on each plot.  Set
#' SUBPROP_UNADJ=1, if only 1 condition per subplot.\cr \tab \tab
#' MICRPROP_UNADJ \tab If microplot tree attributes. Unadjusted proportion of
#' microplot conditions on each plot. Set MICRPROP_UNADJ=1, if only 1 condition
#' per microplot.\cr \tab \tab MACRPROP_UNADJ \tab If macroplot tree
#' attributes. Unadjusted proportion of macroplot conditions on each plot. Set
#' MACRPROP_UNADJ=1, if only 1 condition per macroplot.\cr \tab pltassgn \tab
#' puniqueid \tab Unique identifier for each plot, to link to cond (ex. CN).\cr
#' \tab \tab STATECD \tab Identifies state each plot is located in.\cr \tab
#' \tab INVYR \tab Identifies inventory year of each plot.\cr \tab \tab
#' PLOT_STATUS_CD \tab Status of each plot (i.e. sampled, nonsampled).  If not
#' included, all plots are assumed as sampled.\cr }
#' 
#' For available reference tables: sort(unique(FIESTA::ref_codes$VARIABLE)) \cr
#' 
#' @param popType String. Type of evaluation(s) to include in population data.
#' Note: currently only c('CURR', 'VOL', 'LULC') are available. See details
#' below for descriptions of each.
#' @param popTabs List of population tables the user would like returned.
#'  See help(popTabs()) for a list of options.
#' @param popTabIDs List of unique IDs corresponding to the population tables
#' that the user has requested. See help(popTabIDs()) for a list of
#' options.
#' @param pltassgn DF/DT, Optional. R object, sf R object, comma-delimited
#' file(*.csv), layer or spatial layer in dsn, or shapefile(*.shp). Plot-level
#' assignment of estimation unit and/or strata, with one record for each plot.
#' @param pltassgnid String.
#' @param dsn String. Name of database where tree, cond, and plot-level tables
#' reside.  The dsn varies by driver. See gdal OGR vector formats
#' (https://www.gdal.org/ogr_formats.html).
#' @param pjoinid String. Join variable in plot to match pltassgnid. Does not
#' need to be uniqueid. If using most current XY coordinates for plot
#' assignments, use identifier for plot (e.g., PLOT_ID).
#' @param tuniqueid String. Unique identifier of plot in tree and seed.
#' @param cuniqueid String. Unique identifier of plot in cond.
#' @param condid String. Unique identifier of plot conditions (e.g., CONDID).
#' If no condid in cond, the data are assumed to have 1 condition per plot.  A
#' CONDID=1 is automatically added.
#' @param areawt String. Name of variable for summarizing area weights (e.g.,
#' CONDPROP_UNADJ).
#' @param adj String. How to calculate adjustment factors for nonsampled
#' (nonresponse) conditions based on summed proportions for by plot ('samp',
#' 'plot').  'samp' - adjustments are calculated at strata/estimation unit
#' level; 'plot' - adjustments are calculated at plot-level. Adjustments are
#' only calculated for annual inventory plots (DESIGNCD=1).
#' @param evalid Numeric. FIA Evaluation identifier for subsetting plots for
#' population.
#' @param invyrs Integer vector. Inventory year(s) (e.g., c(2000, 2001, 2002)).
#' @param intensity Integer code. Code(s) indicating intensity to use for
#' population.
#' @param ACI Logical. If TRUE, including All Condition Inventory (ACI) plots.
#' Removes nonsampled nonforest lands (NF_COND_STATUS_CD = 5). Tree data must
#' be included.
#' @param unitvar String. Name of the estimation unit variable in unitarea and
#' cond or pltassgn data frame with estimation unit assignment for each plot
#' (e.g., 'ESTN_UNIT'). Optional if only one estimation unit.
#' @param unitvar2 String. Name of a second level estimation unit variable in
#' unitarea and cond or pltassgn with assignment for each plot (e.g.,
#' 'STATECD').
#' @param unitarea Numeric or DF. Total area by estimation unit. If only 1
#' estimation unit, include number of total acreage for the area of interest or
#' a data frame with area and estimation unit. If more than one estimation
#' unit, provide a data frame of total area by estimation unit, including
#' unitvar and areavar.
#' @param areavar String. Name of area variable in unitarea. Default="ACRES".
#' @param areaunits String. Units of areavar in unitarea ('acres', 'hectares').
#' @param minplotnum.unit Integer. Minimum number of plots for estimation unit.
#' @param unit.action String. What to do if number of plots in an estimation
#' unit is less than minplotnum.unit ('keep', 'remove' 'combine'). If
#' unit.action='combine', combines estimation unit to the following estimation
#' unit, ordered in unitzonal or stratalut.
#' @param unitzonal DF/DT. Table with zonal auxiliary information by estimation
#' unit. For continuous data, means by estimation unit; for categorical data,
#' proportion of class by estimation unit.
#' @param npixelvar String. Name of variable in unitlut defining number of
#' pixels by estimation unit.
#' @param prednames String vector. Name(s) of predictor variables to include in
#' model.
#' @param predfac String vector. Name(s) of prednames that are factors (i.e.,
#' categorical).
#' @param saveobj Logical. If TRUE, saves SApopdat object to outfolder.
#' @param savedata Logical. If TRUE, saves table(s) to outfolder.
#' @param savedata_opts List. See help(savedata_options()) for a list
#' of options. Only used when savedata = TRUE.  
#' @param MAdata List. Data output from FIESTA::MAdata().
#' @param pltdat R List object. Output data list components from
#' FIESTA::spGetPlots().
#' @param auxdat List. Auxiliary data output from FIESTA::spGetAuxiliary().
#' @param gui Logical. If gui, user is prompted for parameters.
#' @param ... For extendibility.
#' @return A list with population data for Green-Book estimates.
#' 
#' \item{condx}{ Data frame. Condition-level data including plot-level
#' assignment of estimation unit and stratum (if strata=TRUE) and adjusted
#' condition proportion. } \item{pltcondx}{ Data frame. Condition-level data,
#' merged with plot data. } \item{cuniqueid}{ String. Unique identifier of plot
#' in condx and pltcondx. } \item{condid}{ String. Unique identifier of
#' condition in condx and pltcondx. } \item{treex}{ Data frame. If
#' esttype='TREE', tree-level data, including sample adjustment factor. }
#' \item{tuniqueid}{ String. If esttype='TREE', unique identifier of plot in
#' treex. } \item{ACI.filter}{ String. If ACI=FALSE, ACI.filter="COND_STATUS_CD
#' == 1" . } \item{unitarea}{ String. Returned table of area by estimation
#' unit. } \item{unitvar}{ String. Variable name for estimation unit. }
#' \item{strlut}{ String. Strata-level table with pixel counts by strata
#' (P1POINTCNT), strata weights (strwt), number of plots by strata (n.strata),
#' total number of plots in estimation unit (n.total), sum of condition
#' proportions (*_UNADJ_SUM), area adjustments (*_ADJFAC), total area, and area
#' expansion by strata (EXPNS). } \item{strvar}{ String. Variable name for
#' strata. If strata=FALSE, strvar="ONESTRAT". } \item{expcondtab}{ String. If
#' ACI=FALSE, ACI.filter="COND_STATUS_CD == 1" . } \item{plotsampcnt}{ Data
#' frame. Number of plots by PLOT_STATUS_CD. } \item{condsampcnt}{ Data frame.
#' Number of conditions by COND_STATUS_CD. } \item{states}{ String. State names
#' in dataset. } \item{invyrs}{ String. Range of inventory years in dataset. }
#' 
#' \item{stratdat}{ Data frame. Strata information by estimation unit. }
#' \tabular{lll}{ \tab \bold{Variable} \tab \bold{Description}\cr \tab unitvar
#' \tab estimation unit \cr \tab strvar \tab stratum value \cr \tab strwtvar
#' \tab number of pixels by strata and estimation unit \cr \tab n.strata \tab
#' number of plots in strata (after totally nonsampled plots removed) \cr \tab
#' n.total \tab number of plots for estimation unit \cr \tab strwt \tab
#' proportion of area (or plots) by strata and estimation unit (i.e., strata
#' weight) \cr \tab CONDPROP_UNADJ_SUM \tab summed condition proportion by
#' strata and estimation unit \cr \tab CONDPROP_ADJFAC \tab adjusted condition
#' proportion by strata after nonsampled plots removed \cr \tab AREA_USED \tab
#' total area of estimation unit \cr \tab expfac \tab strata-level expansion
#' factor after nonsampled plots and conditions removed (AREA_USED/n.strata)
#' \cr \tab EXPNS \tab strata-level area expansions (expfac * strwt)\cr }
#' 
#' Table(s) are also written to outfolder.
#' @note
#' 
#' ADJUSTMENT FACTOR:\cr The adjustment factor is necessary to account for
#' nonsampled conditions. It is calculated for each estimation unit by strata.
#' by summing the unadjusted proportions of the subplot, microplot, and
#' macroplot (i.e. *PROP_UNADJ) and dividing by the number of plots in the
#' strata/estimation unit).
#' 
#' An adjustment factor is determined for each tree based on the size of the
#' plot it was measured on. This is identified using TPA_UNADJ as follows:
#' 
#' \tabular{llr}{ \tab \bold{PLOT SIZE} \tab \bold{TPA_UNADJ} \cr \tab SUBPLOT
#' \tab 6.018046 \cr \tab MICROPLOT \tab 74.965282 \cr \tab MACROPLOT \tab
#' 0.999188 \cr }
#' 
#' If ACI=FALSE, only nonsampled forest conditions are accounted for in the
#' adjustment factor. \cr If ACI=TRUE, the nonsampled nonforest conditions are
#' removed as well and accounted for in adjustment factor.  This is if you are
#' interested in estimates for all lands or nonforest lands in the
#' All-Condition-Inventory.
#' 
#' unitcombine:\cr If TRUE and less than 2 plots in any one estimation unit,
#' all estimation units with 10 or less plots are combined. The current method
#' for combining is to group the estimation unit with less than 10 plots with
#' the estimation unit following in consecutive order (numeric or
#' alphabetical), restrained by survey unit (UNITCD) if included in dataset,
#' and continuing until the number of plots equals 10. If there are no
#' estimation units following in order, it is combined with the estimation unit
#' previous in order.
#' 
#' stratcombine:\cr If TRUE and less than 2 plots in any one strata class
#' within an esimation unit, all strata classes with 2 or less plots are
#' combined. The current method for combining is to group the strata with less
#' than 2 plots with the strata class following in consecutive order (numeric
#' or alphabetical), restrained by estimation unit (if unitcombine=FALSE), and
#' continuing until the number of plots equals 10. If there are no strata
#' classes following in order, it is combined with the estimation unit previous
#' in order.
#' @author Tracey S. Frescino, Paul L. Patterson, Elizabeth A. Freeman
#' @references Scott, Charles T.; Bechtold, William A.; Reams, Gregory A.;
#' Smith, William D.; Westfall, James A.; Hansen, Mark H.; Moisen, Gretchen G.
#' 2005. Sample-based estimators used by the Forest Inventory and Analysis
#' national information management system. Gen. Tech. Rep. SRS-80. Asheville,
#' NC: U.S. Department of Agriculture, Forest Service, Southern Research
#' Station, p.53-77.
#' @keywords data
#' @export modMApop
modMApop <- function(popType="VOL",
                     popTabs = popTables(),
                     popTabIDs = popTableIDs(), 
			               popFilter = popFilters(),
                     pltassgn = NULL,
                     pltassgnid = "PLT_CN",
				             dsn = NULL, 
				             pjoinid = "CN", 
				             areawt = "CONDPROP_UNADJ",
				             adj = "plot", 
				             unitvar = NULL,
				             unitarea = NULL,
				             unitzonal = NULL,
				             prednames = NULL,
				             predfac = NULL,
				             savedata = FALSE, 
                     unit_opts = unit_options(),
				             savedata_opts = savedata_options(),
				             MAdata = NULL, 
				             pltdat = NULL, 
				             auxdat = NULL, 
				             gui = FALSE,
				             ...){

  ##################################################################################
  ## DESCRIPTION:
  ## Generates population data 'on-the-fly', including strata weights, number
  ## of plots by strata and estimation unit, strata-level expansion factors,
  ## and sample-based area adjustment factors.
  ## - checks input parameters and data tables, including removing nonsampled
  ##   plots and conditions (see check.popdata for details).
  ## - checks auxiliary data (i.e., stratification data).
  ## - calculates adjustment factors for nonresponse and appends an adjustment
  ##   variable to condition and tree data.
  ##################################################################################

  ## CHECK GUI - IF NO ARGUMENTS SPECIFIED, ASSUME GUI=TRUE
  if (nargs() == 0) gui <- TRUE

  ## If gui.. set variables to NULL
  if (gui) {
    areavar=strvar=getwt=cuniqueid=ACI=tuniqueid=savedata=unitvar <- NULL
  }

  ## Check input parameters
  input.params <- names(as.list(match.call()))[-1]
  formallst <- names(formals(modMApop)) 
  if (!all(input.params %in% formallst)) {
    miss <- input.params[!input.params %in% formallst]
    stop("invalid parameter: ", toString(miss))
  }
 
  ## Set global variables
  ONEUNIT=n.total=n.strata=strwt=expcondtab=strwtvar <- NULL
  
  ## Set unit defaults
  unit_defaults_list <- formals(FIESTA::unit_options)[-length(formals(FIESTA::unit_options))]
  
  for (i in 1:length(unit_defaults_list)) {
    assign(names(unit_defaults_list)[[i]], unit_defaults_list[[i]])
  }
  
  ## Set user-supplied unit values
  if (length(unit_opts) > 0) {
    for (i in 1:length(unit_opts)) {
      assign(names(unit_opts)[[i]], unit_opts[[i]])
    }
  }
  
  ## Set popFilters defaults
  popFilters_defaults_list <- formals(FIESTA::popFilters)[-length(formals(FIESTA::popFilters))]
  
  for (i in 1:length(popFilters_defaults_list)) {
    assign(names(popFilters_defaults_list)[[i]], popFilters_defaults_list[[i]])
  }
  
  ## Set user-supplied popFilters values
  if (length(popFilter) > 0) {
    for (i in 1:length(popFilter)) {
      assign(names(popFilter)[[i]], popFilter[[i]])
    }
  }

  ## Set savedata defaults
  savedata_defaults_list <- formals(FIESTA::savedata_options)[-length(formals(FIESTA::savedata_options))]
  
  for (i in 1:length(savedata_defaults_list)) {
    assign(names(savedata_defaults_list)[[i]], savedata_defaults_list[[i]])
  }
  
  ## Set user-supplied savedata values
  if (length(savedata_opts) > 0) {
    for (i in 1:length(savedata_opts)) {
      assign(names(savedata_opts)[[i]], savedata_opts[[i]])
    }
  }
  
  ## Set strata defaults
  strata_defaults_list <- formals(FIESTA::strata_options)[-length(formals(FIESTA::strata_options))]
  
  for (i in 1:length(strata_defaults_list)) {
    assign(names(strata_defaults_list)[[i]], strata_defaults_list[[i]])
  }
    
  ## Set popTables defaults
  popTables_defaults_list <- formals(FIESTA::popTables)[-length(formals(FIESTA::popTables))]
  
  for (i in 1:length(popTables_defaults_list)) {
    assign(names(popTables_defaults_list)[[i]], popTables_defaults_list[[i]])
  }
    
  ## Set popTabIDs defaults
  popTableIDs_defaults_list <- formals(FIESTA::popTableIDs)[-length(formals(FIESTA::popTableIDs))]
  
  for (i in 1:length(popTableIDs_defaults_list)) {
    if (names(popTableIDs_defaults_list)[[i]] == "cond") {
      assign("cuniqueid", popTableIDs_defaults_list[[i]])
    }
    if (names(popTableIDs_defaults_list)[[i]] == "plt") {
      assign("puniqueid", popTableIDs_defaults_list[[i]])
    }
    if (names(popTableIDs_defaults_list)[[i]] == "tree") {
      assign("tuniqueid", popTableIDs_defaults_list[[i]])
    }
    if (names(popTableIDs_defaults_list)[[i]] == "seed") {
      assign("suniqueid", popTableIDs_defaults_list[[i]])
    }
    if (names(popTableIDs_defaults_list)[[i]] == "vsubpspp") {
      assign("vsppuniqueid", popTableIDs_defaults_list[[i]])
    }
    if (names(popTableIDs_defaults_list)[[i]] == "vsubpstr") {
      assign("vstruniqueid", popTableIDs_defaults_list[[i]])
    }
    if (names(popTableIDs_defaults_list)[[i]] == "subplot") {
      assign("subpuniqueid", popTableIDs_defaults_list[[i]])
    }
    if (names(popTableIDs_defaults_list)[[i]] == "subp_cond") {
      assign("subcuniqueid", popTableIDs_defaults_list[[i]])
    }
    if (names(popTableIDs_defaults_list)[[i]] == "lulc") {
      assign("lulcuniqueid", popTableIDs_defaults_list[[i]])
    }
  }
  

  ## SET OPTIONS
  options.old <- options()
  options(scipen=8) # bias against scientific notation
  on.exit(options(options.old), add=TRUE)
  adjtree <- FALSE
  popType <- "VOL"
  nonsamp.pfilter=nonsamp.cfilter <- NULL
  returnlst <- list()

  ## Check savedata 
  savedata <- pcheck.logical(savedata, varnm="savedata", 
		title="Save data tables?", first="YES", gui=gui, stopifnull=TRUE)

  ## Check saveobj 
  saveobj <- pcheck.logical(saveobj, varnm="saveobj", 
		title="Save SApopdat object?", first="YES", gui=gui, stopifnull=TRUE)

  ## Check output
  ########################################################
  if (savedata || saveobj) {
    outlst <- pcheck.output(out_dsn=out_dsn, out_fmt=out_fmt, 
		outfolder=outfolder, outfn.pre=outfn.pre, outfn.date=outfn.date, 
		overwrite_dsn=overwrite_dsn, overwrite_layer=overwrite_layer, 
		append_layer=append_layer, gui=gui)
    out_dsn <- outlst$out_dsn
    outfolder <- outlst$outfolder
    out_fmt <- outlst$out_fmt
    overwrite_layer <- outlst$overwrite_layer
    append_layer <- outlst$append_layer
    if (out_fmt != "csv") {
      outfn.date <- FALSE
    }
  } 


  ###################################################################################
  ## Load data
  ###################################################################################
  if (!is.null(MAdata)) {
    list.items <- c("tabs", "dunitarea", "dunitvar", "dunitzonal")
    MAdata <- pcheck.object(MAdata, "MAdata", list.items=list.items)
    #bnd <- MAdata$bnd
    popTabs <- MAdata$tabs
    popTabIDs <- MAdata$tabIDs
    pltassgn <- MAdata$pltassgn
    pltassgnid <- MAdata$pltassgnid
    unitarea <- MAdata$dunitarea
    areavar <- MAdata$areavar
    unitzonal <- MAdata$dunitzonal
    puniqueid <- MAdata$puniqueid
    pjoinid <- MAdata$pjoinid

    if (is.null(unitvar)) {
      unitvar <- MAdata$dunitvar
      unitvar2 <- MAdata$dunitvar2
    } 
    if (is.null(npixelvar)) {
      npixelvar <- MAdata$npixelvar
    }
    if (is.null(prednames)) {
      prednames <- MAdata$prednames
    } else {
      if (!all(prednames %in% MAdata$prednames)) {
        stop("invalid prednames: ", 
	 	toString(prednames[!prednames %in% MAdata$prednames]))
      }
    }
    if (is.null(predfac)) {
      predfac <- MAdata$predfac
    }
    predfac <- predfac[predfac %in% prednames]
    
  } else {
    if (!is.null(pltdat)) {
      popTabs <- pltdat$tabs
      popTabIDs <- pltdat$tabIDs
      pjoinid <- pltdat$pjoinid
      names(popTabs) <- sapply(names(popTabs), function(x) 
		{ifelse(endsWith(x, "x"), substr(x, 1, nchar(x)-1), x)})
      names(popTabIDs) <- sapply(names(popTabIDs), function(x) 
		{ifelse(endsWith(x, "x"), substr(x, 1, nchar(x)-1), x)})
    }
    if (!is.null(auxdat)) {
      list.items <- c("pltassgn", "dunitzonal", "dunitvar", "predfac", "npixelvar", 
		"pltassgnid", "dunitarea", "areavar")
      auxdat <- pcheck.object(auxdat, "auxdat", list.items=list.items)
      pltassgn <- auxdat$pltassgn
      pltassgnid <- auxdat$pltassgnid
      unitzonal <- auxdat$dunitzonal
      unitvar <- auxdat$dunitvar
      unitvar2 <- auxdat$dunitvar2
      unitarea <- auxdat$dunitarea
      areavar <- auxdat$areavar

      if (is.null(npixelvar)) {
        npixelvar <- auxdat$npixelvar
      }
      if (is.null(prednames)) {
        prednames <- auxdat$prednames
      } else {
        if (!all(prednames %in% auxdat$prednames))
          stop("invalid prednames: ", 
	 	toString(prednames[!prednames %in% auxdat$prednames]))
      }
      if (is.null(predfac)) {
        predfac <- auxdat$predfac
      }
      predfac <- predfac[predfac %in% prednames]
    }
  } 

  if (strata) {
    if (is.null(strvar)) {    
      if (!is.null(predfac) && length(predfac) == 1) {
        strvar <- predfac
      } else {
        stop("must include strvar if strata=TRUE")
      }
    } else {
      if (!strvar %in% predfac) {
        stop("strvar must be included in predfac")
      }
    } 
    if (is.null(strwtvar)) {
      strwtvar <- "Prop"
    }
    prednames <- NULL
    pivotvars <- c(unitvar, unitvar2, "AOI", "npixels")
    unitvars <- pivotvars[pivotvars %in% names(unitzonal)]
    if (is.null(stratalut)) {
      stratalut <- strat.pivot(unitzonal, strvar, unitvars=unitvars, 
		strwtvar=strwtvar)
    }
  }

  ## Set user-supplied popTable values 
  if (length(popTabs) > 0) {
    for (i in 1:length(popTabs)) {
      assign(names(popTabs)[[i]], popTabs[[i]])
    }
  } else {
    stop("need to include popTabs")
  }

  list.items <- {}
  if (popType == "LULC") {
    list.items <- c(list.items, "lulcx")
  }
  if (popType == "P2VEG") {
    list.items <- c(list.items, "vsubpspp", "vsubpstr", "subplot", "subp_cond")
  }
  popTabs <- pcheck.object(popTabs, "popTabs", list.items=list.items)

 
  ## Set user-supplied popTabIDs values
  if (length(popTabIDs) > 0) {
    for (i in 1:length(popTabIDs)) {
      if (names(popTabIDs)[[i]] == "cond") {
        assign("cuniqueid", popTabIDs[[i]])
      }
      if (names(popTabIDs)[[i]] == "plt") {
        assign("puniqueid", popTabIDs[[i]])
      }
      if (names(popTabIDs)[[i]] == "tree") {
        assign("tuniqueid", popTabIDs[[i]])
      }
      if (names(popTabIDs)[[i]] == "seed") {
        assign("suniqueid", popTabIDs[[i]])
      }
      if (names(popTabIDs)[[i]] == "vsubpspp") {
        assign("vsppuniqueid", popTabIDs[[i]])
      }
      if (names(popTabIDs)[[i]] == "vsubpstr") {
        assign("vstruniqueid", popTabIDs[[i]])
      }
      if (names(popTabIDs)[[i]] == "subplot") {
        assign("subpuniqueid", popTabIDs[[i]])
      }
      if (names(popTabIDs)[[i]] == "subp_cond") {
        assign("subcuniqueid", popTabIDs[[i]])
      }
      if (names(popTabIDs)[[i]] == "lulc") {
        assign("lulcuniqueid", popTabIDs[[i]])
      }
    }
  }
 
  ###################################################################################
  ## CHECK PARAMETERS AND DATA
  ## Generate table of sampled/nonsampled plots and conditions
  ## Remove nonsampled plots and conditions (if nonsamp.filter != "NONE")
  ## Applies plot and condition filters
  ###################################################################################
  popcheck <- check.popdata(gui=gui, module="MA", popType=popType, 
 	tabs=popTabs, tabIDs=popTabIDs, pltassgn=pltassgn, dsn=dsn, 
 	pltassgnid=pltassgnid, pjoinid=pjoinid, condid="CONDID", 
	evalid=evalid, invyrs=invyrs, measCur=measCur, measEndyr=measEndyr, 
	intensity=intensity, ACI=ACI, areawt=areawt, adj=adj, 
	nonsamp.pfilter=nonsamp.pfilter, nonsamp.cfilter=nonsamp.cfilter, 
	unitarea=unitarea, unitvar=unitvar, unitvar2=unitvar2, areavar=areavar, 
	areaunits=areaunits, unit.action=unit.action, strata=strata,
	stratalut=stratalut, strvar=strvar, stratcombine=stratcombine, 
	prednames=prednames, predfac=predfac)
  if (is.null(popcheck)) return(NULL)
  condx <- popcheck$condx
  pltcondx <- popcheck$pltcondx
  treef <- popcheck$treef
  seedf <- popcheck$seedf
  pltassgnx <- popcheck$pltassgnx
  cuniqueid <- popcheck$cuniqueid
  condid <- popcheck$condid
  tuniqueid <- popcheck$tuniqueid
  pltassgnid <- popcheck$pltassgnid
  ACI.filter <- popcheck$ACI.filter
  adj <- popcheck$adj
  unitvar <- popcheck$unitvar
  unitvar2 <- popcheck$unitvar2
  unitarea <- popcheck$unitarea
  areavar <- popcheck$areavar
  areaunits <- popcheck$areaunits
  unit.action <- popcheck$unit.action
  strata <- popcheck$strata
  stratalut <- popcheck$stratalut
  stratcombine <- popcheck$stratcombine
  strvar <- popcheck$strvar
  prednames <- popcheck$prednames
  predfac <- popcheck$predfac
  P2POINTCNT <- popcheck$P2POINTCNT 
  plotsampcnt <- popcheck$plotsampcnt
  condsampcnt <- popcheck$condsampcnt
  states <- popcheck$states
  invyrs <- popcheck$invyrs
  cvars2keep <- popcheck$cvars2keep
  pvars2keep <- popcheck$pvars2keep

  ###################################################################################
  ## CHECK ESTIMATION UNIT or STRATA
  ###################################################################################
  ## If strata=TRUE, check strata variables and number of plots by estimation unit
  ## - if < 2 plots, an error occurs, must collapse plots.
  ## - if 2-10 plots, a warning is displayed, with suggestion to collapse plots. 
  ## - if stratcombine=TRUE, combines strata classes to reach minplotnum.strat. 
  ## - if unit.action='combine', combines estimation units to reach minplotnum.unit.
  ###################################################################################
  if (strata) {
      auxlut <- stratalut
      makedummy <- FALSE
  } else {
      auxlut <- unitzonal
      makedummy <- TRUE
  }
  auxdat <- check.auxiliary(pltx=pltassgnx, puniqueid=pltassgnid, 
        	module="MA", strata=strata, unitvar=unitvar, unitvar2=unitvar2, 
		unitarea=unitarea, areavar=areavar, minplotnum.unit=minplotnum.unit,
 		unit.action=unit.action, auxlut=auxlut, prednames=prednames, 
		strvar=strvar, predfac=predfac, makedummy=makedummy, npixelvar=npixelvar, 
		strwtvar="Prop", stratcombine=stratcombine, minplotnum.strat=minplotnum.strat, 
		removeifnostrata=TRUE, standardize=TRUE)
  pltassgnx <- setDT(auxdat$pltx)
  unitarea <- auxdat$unitarea
  unitvar <- auxdat$unitvar
  unitvars <- auxdat$unitvars
  unitlut <- auxdat$auxlut
  prednames <- auxdat$prednames
  predfac <- auxdat$predfac
  npixels <- auxdat$npixels
  stratcombinelut <- auxdat$unitstrgrplut
  strvar <- auxdat$strvar
  unitNA <- auxdat$unitNA
  if (is.null(key(pltassgnx))) setkeyv(pltassgnx, pltassgnid)


  ###################################################################################
  ## GET ADJUSTMENT FACTORS BY STRATA AND/OR ESTIMATION UNIT FOR NONSAMPLED CONDITIONS
  ## Calculates adjustment factors for area and trees by strata (and estimation unit)
  ##		to account for nonsampled plots and conditions.
  ## Creates an adjusted condition proportion by merging strata-level adjustment
  ##		factors to cond and dividing CONDPROP_UNADJ by adjustment factor.
  ###################################################################################
  ## Returns:
  ##  1. Summed proportions (*PROP_UNADJ_SUM) and adjustment factors (*PROP_ADJFAC)  
  ##     by strata and estunit (*PROP_UNADJ_SUM / n.strata)
  ##  2. Adjusted condition proportion (CONDPROP_ADJ) appended to condx
  ###################################################################################
  ## Merge plot strata info to condx
  if (is.null(key(condx))) setkeyv(condx, c(cuniqueid, condid))
  condx <- condx[pltassgnx[,c(pltassgnid, unitvar, strvar, prednames), with=FALSE]]

  ## If more than one unitvar, 
  ## split the concatenated unitvar variable to keep original columns
  if (!is.null(unitvar2)) {
    condx[, (unitvars) := tstrsplit(get(unitvar), "-", fixed=TRUE)]
  }
  if (adj == "samp") {
    bycond <- TRUE
    adjtree <- TRUE
    adjfacdata <- getadjfactorGB(treex=treef, seedx=seedf, condx=condx, 
		tuniqueid=tuniqueid, cuniqueid=cuniqueid, condid=condid, unitlut=unitlut, 
		unitvars=unitvar, strvars=strvar, unitarea=unitarea, areavar=areavar, 
		cvars2keep=cvars2keep)
    condx <- adjfacdata$condx
    unitlut <- adjfacdata$unitlut
    treef <- adjfacdata$treex
    seedf <- adjfacdata$seedx
    expcondtab <- adjfacdata$expcondtab
 
  } else if (adj == "plot") {
    adjtree <- TRUE
    bycond <- FALSE
    adjfacdata <- getadjfactorPLOT(treex=treef, condx=condx, 
		tuniqueid=tuniqueid, cuniqueid=cuniqueid)
    condx <- adjfacdata$condx
    treef <- adjfacdata$treex
    seedf <- adjfacdata$seedx

  } else {
    setkeyv(condx, c(cuniqueid, condid))
  }
 
  ###################################################################################
  ## Return population data objects
  ###################################################################################
  estvar.area <- ifelse(adj == "none", "CONDPROP_UNADJ", "CONDPROP_ADJ")
  returnlst <- list(condx=condx, pltcondx=pltcondx, cuniqueid=cuniqueid, 
	condid=condid, ACI.filter=ACI.filter, unitarea=unitarea, areavar=areavar,
	areaunits=areaunits, unitvar=unitvar, unitvars=unitvars, unitlut=unitlut, 
	npixels=npixels, npixelvar=npixelvar, prednames=prednames, 
	expcondtab=expcondtab, plotsampcnt=plotsampcnt, condsampcnt=condsampcnt, 
	states=states, invyrs=invyrs, estvar.area=estvar.area, strata=strata, adj=adj)

  if (!is.null(treef)) {
    returnlst$treex <- treef
    returnlst$tuniqueid <- tuniqueid
    returnlst$adjtree <- adjtree
  }
  if (!is.null(seedf)) {
    returnlst$seedx <- seedf
  }
  returnlst$prednames <- prednames
  returnlst$predfac <- predfac

  if (strata) {
    setkeyv(unitlut, c(unitvar, unitvar2, strvar))
    returnlst$unitlut <- unitlut
    returnlst$strvar <- strvar
    if (!is.null(stratcombinelut)) {
      returnlst$stratcombinelut <- stratcombinelut
    }
  }


  ###################################################################################
  ## Save population data objects
  ###################################################################################

  if (saveobj) {
    objfn <- getoutfn(outfn="MApopdat", outfolder=outfolder, 
		overwrite=overwrite_layer, outfn.date=outfn.date, ext="rda")
    save(returnlst, file=objfn)
    message("saving object to: ", objfn)
  } 

  if (savedata) {
    datExportData(condx, outfolder=outfolder, 
		out_fmt=out_fmt, out_dsn=out_dsn, out_layer="condx", 
		outfn.date=outfn.date, overwrite_layer=overwrite_layer,
		add_layer=TRUE, append_layer=append_layer)
    datExportData(pltcondx, outfolder=outfolder, 
		out_fmt=out_fmt, out_dsn=out_dsn, out_layer="pltcondx", 
		outfn.date=outfn.date, overwrite_layer=overwrite_layer,
		add_layer=TRUE, append_layer=append_layer)

    if (!is.null(treef)) {
      datExportData(treef, outfolder=outfolder, 
		out_fmt=out_fmt, out_dsn=out_dsn, out_layer="treex", 
		outfn.date=outfn.date, overwrite_layer=overwrite_layer,
		add_layer=TRUE, append_layer=append_layer)
    }
    if (!is.null(seedf)) {
      datExportData(seedf, outfolder=outfolder, 
		out_fmt=out_fmt, out_dsn=out_dsn, out_layer="seedx", 
		outfn.date=outfn.date, overwrite_layer=overwrite_layer,
		add_layer=TRUE, append_layer=append_layer)
    }

    datExportData(pltassgnx, outfolder=outfolder, 
		out_fmt=out_fmt, out_dsn=out_dsn, out_layer="pltassgn", 
		outfn.date=outfn.date, overwrite_layer=overwrite_layer,
		add_layer=TRUE, append_layer=append_layer)
    datExportData(unitarea, outfolder=outfolder, 
		out_fmt=out_fmt, out_dsn=out_dsn, out_layer="unitarea", 
		outfn.date=outfn.date, overwrite_layer=overwrite_layer,
		add_layer=TRUE, append_layer=append_layer)
    datExportData(unitlut, outfolder=outfolder, 
		out_fmt=out_fmt, out_dsn=out_dsn, out_layer="unitlut", 
		outfn.date=outfn.date, overwrite_layer=overwrite_layer,
		add_layer=TRUE, append_layer=append_layer)
  }

  return(returnlst)
}

