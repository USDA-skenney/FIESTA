---
title: "FIESTA - Green-book Estimators"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{FIESTA - Green-book Estimators}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include = F}
library(knitr)
knitr::opts_chunk$set(message = F, warning = F)
```

```{r, include=FALSE}
# Sets up output folding
hooks = knitr::knit_hooks$get()
hook_foldable = function(type) {
  force(type)
  function(x, options) {
    res = hooks[[type]](x, options)
    
    if (isFALSE(options[[paste0("fold.", type)]])) return(res)
    
    paste0(
      "<details><summary>", type, "</summary>\n\n",
      res,
      "\n\n</details>"
    )
  }
}
knitr::knit_hooks$set(
  output = hook_foldable("output"),
  plot = hook_foldable("plot")
)
```

## `FIESTA` Overview

The `R` package, `FIESTA` (Forest Inventory ESTimation and Analysis) is a research estimation tool for analysts that work with sample-based inventory data from the U.S. Department of Agriculture, Forest Service, Forest Inventory and Analysis (FIA) Program. `FIESTA` can generate FIA's traditional state-wide estimates while also accommodate: unique population boundaries, different evaluation time periods, customized stratification schemes, non-standard variance equations, integration of multi-scale remotely-sensed data and other auxiliary information, and interaction with other modeling and estimation tools from CRAN's library of packages. `FIESTA` contains a collection of functions that can access FIA databases, summarize and compile plot and spatial data, and generate estimates with associated sampling errors. 

Functions are organized by type or objective and are named with a corresponding prefix (Fig. 1). `FIESTA` core functions (CORE) facilitate data extraction and compilation of data input information and are used independently or within the `FIESTA` estimation modules. `FIESTA` estimation modules (MODULE) combine multiple functions from `FIESTA` or other packages to generate population estimates using different estimation strategies. Each module has an associated `mod*pop` function for compiling the population data and calculations (e.g., adjustments for nonresponse, standardizing auxiliary data) for a custom boundary and can be used for generating multiple estimates. `FIESTA` analysis functions, found in the `FIESTAnalysis` package, streamline different estimation routines by wrapping (i.e., combining) estimation modules and other functions for a specific purpose. 

**Core Functions**

* Database tools (`DB*`) - functions for querying and extracting data from FIA's national database.
* Data tools (`dat*`) - functions for summarizing and exploring FIA data.
* Spatial tools (`sp*`) - functions for manipulating and summarizing spatial data.

**Estimation Modules (mod) **

* Green-Book (`modGB*`) - functions for FIA's standard Green-Book estimators.
* Photo-Based (`modPB*`) - functions for supplementary photo-based estimators.
* Small Area (`modSA*`) - functions for integration with available small area estimators (SAE).
* Model-Assisted (`modMA*`) - functions for integration with available Model-Assisted estimators.

**Analysis Functions**

* Analysis functions (`an*`) - wrapper functions for steam-lining estimation processes. These functions reside in the `FIESTAnalysis` package. 

## Green-Book (GB) module overview

`FIESTA`'s Green-Book (GB) module calculates population estimates and their sampling errors based on Bechtold and Patterson's (2005), 'Green-Book' for FIA's nationally-consistent, systematic annual sample design, chapter 4 (Scott et al. 2005). FIA's sample design is based on 2 phases: the first phase uses remotely-sensed data to stratify the land area to increase precision of estimates; while the 2nd phase obtains photo and ground observations and measurements for a suite of information across a hexagonal grid, each approximately 6000 acres in size. The associated estimators and variance estimators are used for area and tree attribute totals with the assumption of a simple random, stratified design and double sampling for stratification. Adjustment factors are calculated by estimation unit and strata to account for nonsampled (nonresponse) conditions.   

Functions include non-ratio estimators for area and tree estimates by domain and ratio-of-means estimators for per-acre and per-tree estimates within domain. In addition, `FIESTA` adjusts for nonsampled conditions, supports post-stratification for reducing variance, and reports by estimation unit or a summed combination of estimation units. Output from the Green-Book module was tested and compared to output from FIA's publicly-available online tool (EVALIDator - https://apps.fs.usda.gov/Evalidator/evalidator.jsp) for state-level population estimates and associated sampling errors generated from the FIA Database (FIADB).

## Objective of tutorial

The Green-Book estimators can be used with FIA's standard state-level population data (i.e, Evaluation) from the FIA database (FIADB) and also population data from a custom boundary. The population data includes a set of FIA plot data and summarized auxiliary information for post-stratification, including a table of area by estimation unit within the population, and a table of strata proportions by estimation unit. This tutorial steps through using FIESTA's Green Book module for either situation.

* [Green-Book parameters](#input)
* [Required variables for input tables](#required)
* [FIESTA output from Green-Book module](#output)
* [Reference tables](#ref)
* [GB Functions and Examples](#GBfun)


## Green-Book Parameters {#input}


The parameters for GB functions are organized by different categories based on population data and estimation output.

[Population data](#popdat):

1. [Population type](#ptyp)  
2. [Data tables and unique identifiers of plot](#dtab)  
3. [Estimation data](#edata)   
4. [Nonsample filters](#nonsamp)
5. [Estimation unit information](#estunit)
6. [Stratification information](#strat)

[Estimation output](#estout):

1. [Plot/condition filters to subset table records](#filt)
2. [Tree information for tree estimates - modGBtree()](#tree) 
3. [Tree information for ratio estimates - modGBratio()](#rat)
4. [Output table information](#out1)
5. [Output table specifications](#out2)
6. [Output table title(s)](#title)



### Population Data {#popdat}
<details>
  <summary>View Population Data Parameters</summary>

<a name="ptyp"></a>
**Population type**

The population types (i.e., Eval_Type) currently available for `FIESTA` estimation. The population type defines the set of sampled plots and data used for estimation. For example, if you are only interested in area estimates (popType='CURR'), you do not need the tree data. Other population types will be available in the future, including GRM (Growth, mortality, removals), P2VEG (understory vegetation), CHNG (Change), and DWM (down woody material). These population types may have different sets of plots based on what was sampled.

* **popType**    - Population type ('ALL', 'CURR', 'VOL').


<a name="dtab"></a>
**Population data tables and unique identifiers**

The required data tables are from the FIA national database. Plot-level information, such as: state, county, or strata assignment may be included in the pltassgn table, or cond table (with pltassgn=NULL). The data table inputs can be the name of a comma-delimited file (\*.csv), a layer within a database, (e.g., SQLite), or an R data frame or data table object already loaded into R. The pltassgn table can also be a point shapefile (\*.shp), a spatial layer within a database, or a sf R object with one point per plot. The unique identifier for a plot must be provided in the corresponding parameter for each input table. See required variables section for a list of variables necessary to include for estimation.

* **popTables**   - A named list of data tables used for estimates (cond, plt, tree, seed, vsubpspp, vsubpstr, subplot, subp_cond). See below for more details about tables.

  + **cond**      - Condition-level data, with 1 record per condition, including nonsampled conditions. May include estimation unit and strata assignment if plt=NULL and pltassgn=NULL - *required for all estimates*. 
  + **tree**      - Tree-level data, with 1 record per tree - *required for modGBtree() or modGBratio() tree estimates*.
  + **plt**       - Plot-level data, with 1 record per plot, including nonsampled conditions. May include nonsampled plots if PLOT_STATUS_CD variable is in dataset. May include estimation unit and strata assignment if pltassgn=NULL - *optional for all estimates*. 
  + **seed**      - Seedling data, with 1 record per seedling count - *required for modGBtree() or modGBratio() seedling estimates*.

* **popTableIDs**   - A named list of variable names defining unique plot identifiers in each table listed in popTables. See below for more details about tables.

  + **cond** - Unique identifier for plot in cond (default="PLT_CN").
  + **plt**  - Unique identifier for plot in plt (default="CN").
  + **tree** - Unique identifier for plot in tree (default="PLT_CN").
  + **seed** - Unique identifier for plot in seed (default="PLT_CN").
  + **vsubpspp** - Unique identifier for plot in vsubpspp (default="PLT_CN").
  + **vsubpstr** - Unique identifier for plot in vsubpstr (default="PLT_CN").
  + **subplot**  - Unique identifier for plot in subplot (default="PLT_CN").
  + **subp_cond** - Unique identifier for plot in subp_cond (default="PLT_CN").

* **pltassgn**  - Plot-level data, with 1 record per plot and plot assignment of estimation unit and strata, if applying stratification. If nonsampled plots are included, PLOT_STATUS_CD variable must be in table. These plots are excluded from the analysis.       - *optional for all estimates*.
* **pltassgnid**- Unique identifier for plot in pltassgn (default="PLT_CN").
* **pjoinid**   - Join variable in plot (or cond) to match pltassgnid. Does not need to be unique.

* **dsn**       - Data source name of database where data table layers reside.



<a name="edata"></a>
**Estimation area info**

Define information for area estimation.

* **areawt**    - Variable to use for calculating area estimates (e.g., CONDPROP_UNADJ). This may be different for other population types.
* **adj**       - Adjustment for nonresponse ('none', 'samp', 'plot'). Note: adj='samp', expands area across strata and estimation unit(s), based on the summed proportions of sampled conditions divided by the total plots in the strata/estimation unit; adj='plot', expands area across plot based on 1 divided by the summed proportions of sampled conditions in plot.


<a name="popfilters"></a>
**Population filters**

Population filters subset the plot data set before population calculations are generated. 

* **evalid**    - If multiple evaluations are in dataset, select evalid for estimation.
* **invyrs**    - If want to subset inventory years in dataset for estimation.
* **intensity** - If want to specify intensification number of code to use for estimation.
* **ACI**       - Logical. If TRUE, includes All Condition Inventory (ACI) conditions and associated tree data in estimates. If FALSE, a filter, is applied to remove nonsampled nonforest conditions (see cond.nonsamp.filter).


<a name="estunit"></a>
**Estimation unit information**

An estimation unit is a population, or area of interest, with known area and number of plots. As an example, for RMRS FIA states, an estimation unit is generally an individual county. An estimation unit may be a subpopulation of a larger population (e.g., Counties within a State). Subpopulations are mutually exclusive and independent within a population, therefore estimated totals and variances are additive. Each plot is assigned to only one estimation unit based on plot center and can be stored in either pltassgn or cond. 

* **unitvar** - Name of the estimation unit variable in cond or pltassgn with assignment for each plot (e.g., 'ESTN_UNIT').
* **unitvar2** - Name of a second estimation unit variable in cond or pltassgn with assignment for each plot (e.g., 'STATECD').
* **unitarea**  - Total acres by estimation unit. If only 1 estimation unit, include a number representing total acreage for the area of interest. If more than one estimation unit, provide a data frame/data table of total acres by estimation unit, with variables defined by unitvar and areavar. 
* **areavar**   - Name of acre variable in unitarea (Default = "ACRES").
* **areaunits** - Units of areavar in unitarea ('acres', 'hectares').
* **minplotnum.unit** - Minimum number of plots for estimation unit (Default=10).
* **unit.action** - What to do if number of plots in an estimation unit is less than minplotnum.unit ('keep', 'remove' 'combine'). If unit.action='combine', combines estimation unit to the following estimation unit in unitlut.


**Other**

* **strata**  - TRUE, use post-stratification for reducing variance in estimates (see strata_opts for strata parameters.
* **savedata**  - TRUE, save data to outfolder (See savedata_opts for savedata parameters).


<a name="strata_opts"></a>
**Post-stratification information (strata_opts)**

Post-stratification is used to reduce variance in population estimates by partitioning the population into homogenous classes (strata), such as forest and nonforest. For stratified sampling methods, the strata sizes (weights) must be either known or estimated. Remotely-sensed data is often used to generate strata weights with proporation of pixels by strata. If stratification is desired (strata=TRUE), the required data include: stratum assignment for the center location of each plot, stored in either pltassgn or cond; and a look-up table with the area, pixel count, or proportion of the total area (strwt) of each strata value by estimation unit, making sure the name of the strata (and estimation unit) variable and values match the plot assignment name(s) and value(s). If strata (and estimation unit) variables are included in cond, all conditions in a plot must have the same strata (and estimation unit) value.

In FIESTA, the plot assignments, strata proportions, and area are provided by the user and may be obtained through FIESTA or other means, given the proper format. These parameters are set by supplying a list to the `strata_opts` parameter. The possible parameters that can be set within the `strata_opts` parameter can be seen by running `help(strata_options)`


* **stratalut** - Look-up table with pixel counts, area, or proportions (strwt) by strata (and estimation unit).
* **strvar**    - Name of strata variable in stratalut and pltassgn or cond table with strata assignment for each plot.
* **getwt**     - If TRUE, calculates strata weights from getwtvar in stratalut.
* **getwtvar**  - If getwt=TRUE, name of variable in stratalut to calculate weights Default="P1POINTCNT". 
* **strwtvar**  - If getwt=FALSE, name of variable in stratalut with calculated weights (Default = 'strwt'). 
* **stratcombine** - TRUE, and strata=TRUE, an automated procedure occurs to combine strata within estimation units if less than minplotnum.strat (See note below for more details).
* **minplotnum.strat** - Integer. Minimum number of plots for a stratum within an estimation unit (Default=2). 


Note: 
If there are less than minplotnum.strat plots (default=2 plots) in any strata/estimation combination: if stratcombine=FALSE, an error occurs with a message to collapse classes; if stratcombine=TRUE, an automated procedure occurs to collapse all strata less than minplotnum.strat. The function collapses classes based on the order of strata in stratatlut. If a strata within in estimation unit is less than minplotnum.strat, it is grouped with the next strata class in stratalut. If there are less than minplotnum.unit plots in an estimation unit: if unit.action='keep', NA is returned for the estimation unit; if unit.action='remove', the estimation unit is removed from the returned output; if unit.action='combine', an automated procedure occurs to group estimation units with less tha 10 plots with the next estimation unit in the stratalut. If it is the last estimation unit in the table, it is grouped with the estimation unit preceeding in the table. A recommended number of plots is provided as defaults (Westfall and others, 2011). 


<a name="Data objects"></a>
**Input data objects**

Data object parameters allow a user to use other functions from FIESTA to input parameters directly. 

* **GBdata**   - Output data list components from FIESTA::anGBdata().
* **pltdat**   - Output data list components from FIESTA::pltdat().
* **GBstratdat**  - Output data list components from FIESTA::GBstratdat(). 

</details>

<a name="Population Output"></a>

### Output values from `FIESTA` Green-Book module - modGBpop()

<details>
  <summary>View Output Values</summary>

* **condx**       - Data frame of condition data within population, including plot assignments, condition proportion adjustment factor (cadjfac), and adjusted condition proportions (CONDPROP_ADJ).
* **pltcondx**    - Data frame of plot/condition data within population, used for estimation.
* **treex**       - Data frame of tree data within population, used for estimation, including trees per acre adjustment factor (tadjfac), and adjusted trees per acre (TPA_ADJ).
* **cuniqueid**   - Unique identifier of plot in condx and pltcondx.
* **tuniqueid**   - Unique identifier of plot in treex.
* **condid**      - Unique identifier of condition in condx and pltcondx.
* **ACI.filter**  - Filter used for excluding ACI plots if ACI=FALSE.
* **unitvar**     - Name of estimation unit variable in unitarea and condx.
* **unitarea**    - Data frame with area by estimation unit.
* **areavar**     - Name of area variable in unitarea.
* **stratalut**      - Data frame of stratification information by estimation unit. See below for variable descriptions.
* **strvar**      - Name of strata variable in stratalut and condx 
* **expcondtab**  - Data frame of condition-level area expansion factors.
* **plotsampcnt** - Number of plots by plot status.
* **condsampcnt** - Number of conditions by condition status.
* **states**      - States of FIA plot data used in estimation (for title reference).
* **invyrs**      - Inventory years of FIA plot data used in estimation (for title reference).


```{r, results = 'asis', echo=FALSE}

#stratdat.lut <- read.csv("C:/_tsf/_GitHub/meta/stratdat_variables.csv", stringsAsFactors=FALSE)
#source("C:/_tsf/_GitHub/meta/undataframe.R")
#stratdat.lut <- undataframe(stratdat.lut)

stratdat.lut <- data.frame(
Variable = c("ESTN_UNIT", "STRATUMCD", "P1POINTCNT", "P2POINTCNT", "n.strata", "n.total", "strwt", "CONDPROP_UNADJ_SUM", "cadjfac", "ACRES", "expfac", "EXPNS"), 
Description = c("Estimation unit", "Strata value", "Number of pixels by strata and estimation unit", "Number of P2 plots in population data", "Number of sampled plots in strata", "Number of sampled plots for estimation unit", "Proportion of pixels in strata (strata weight)", "Summed condition proportion in strata", "Adjustment factor for nonsampled plots in strata (CONDPROP_UNADJ_SUM/n.strata)", "Total acres for estimation unit", "Expansion factor, in acres, area in strata divided by number of sampled plots", "Expanded area, in acres, expfac multiplied by strwt"), 
    stringsAsFactors = FALSE)


kable(stratdat.lut,
  format = "pandoc",   # default
  caption = "Description of variables in stratdat.",
  col.names = names(stratdat.lut),
  row.names = FALSE,
  align = c("l"),       # align = c("c", "c", "c", "r")
  # padding = 2         # inner spacing
) 

```



</details>

### Estimation Output {#estout}
<details>
  <summary>View Estimation Output</summary>

<a name="filt"></a>
**Estimation Filters**

Filters subset the area of the sample population for the desired output. Filters do no change the population data used for estimate (e.g., number of plots, strata weights). Some filters are defined internally, depending on the dataset, such as land area of interest (landarea) or inclusion of ACI (All Condition Inventory) data. Others are specified according to the input table, such as pfilter or cfilter. The nonsamp.filter is for removing nonsampled conditions and is applied, internally, unless otherwise stated. *All filter expressions must be in R syntax*.

* **landarea**       - A predefined cond filter depending on desired sample land area {ALL, FOREST (COND_STATUS_CD=1), TIMBERLAND (SITECLCD in(1:6) & RESERVCD=0)}.
* **pfilter**    - Plot-level filter.
* **cfilter**    - Condition-level filter.


<a name="tree"></a>
**Tree information for tree estimates - modGBtree()**

Tree information is used for calculating estimates for derived tree data, such as basal area (BA), volume (e.g., VOLCFNET), or number of trees (i.e., TPA_UNADJ). All variables except number of tree variables are extrapolated to the acre plot size by multiplying by TPA_*). 

* **estvar**        - Name of estimate variable in tree (e.g., VOLCFNET, TPA_UNADJ).
* **estvar.filter** - Tree-level filter (e.g., 'STATUS_CD == 1 & DIA >= 5.0').
* **estvar.name**   - A name for aggregated estvar (Default = estvar'_SUM').

<a name="rat"></a>
**Tree information for ratio estimates - modGBratio()**

Tree information is used for calculating per-acre ratio estimates (numerator) and per-tree ratio estimates (numerator and denominator) from derived tree data, such as basal area (BA), volume (e.g., VOLCFNET), or number of trees (i.e., TPA_UNADJ). All variables except number of tree variables are extrapolated to the acre plot size by multiplying by TPA_*).

* **ratiotype** - If ratio estimate, the ratio type ("PERACRE", "PERTREE").
* **estvar(n)**        - Numerator - Name of estimate variable (e.g., VOLCFNET, TPA_UNADJ)
* **estvar(n).filter** - Numerator - Tree-level filter(s).
* **estvar(n).name**   - Numerator - A name for aggregated estvar (Default = estvar(n)'_SUM').
* **estvard**        - Denominator - Name of estimate variable (e.g., VOLCFNET, TPA_UNADJ)
* **estvard.filter** - Denominator - Tree-level filter(s).
* **estvard.name**   - Denominator - A name for aggregated estvar (Default = estvard'_SUM').


**Table estimates**

Estimates can be broken down by categorical domains for further detail about a population. These details are presented as rows or rows and columns in a matrix table, with a separate, associated sampling error for each cell in the table. If the area of interest (i.e., population) has more than one estimation unit (i.e., subpopulation), estimates may be presented by estimation unit or summed to the population. 

* **rowvar**    - Name of row variable (domain). If area estimate, rowvar must be from cond (e.g., FORTYPCD). If tree or ratio estimate, rowvar can be from cond or tree (e.g., SPCD).
* **colvar**    - Name of column variable (domain). If area estimate, colvar must be from cond (e.g., FORTYPCD). If tree or ratio estimate, colvar can be from cond or tree (e.g, SPCD).
* **sumunits**  - TRUE, sum estimates by estimation units (sub-populations) into one estimate (e.g., Counties to State).


**Other**

* **returntitle**  - TRUE, return table titles (See title_opts for more title parameters)
* **savedata**  - TRUE, save data to outfolder (See savedata_opts for more savedata parameters).


<a name="table_opts"></a>
**Output table options (table_opts)**

The following parameters provide more detail about the presentation and aesthetics of the final output table, including: using code names instead of codes; applying specific ordering; adding categories not in the data set with 0 values; displaying percent standard errors and estimates together or separate; and rounding options. These parameters are set by supplying a list to the `table_opts` parameter. The possible parameters that can be set within the `table_opts` parameter can be seen by running `help(table_options)`.

* **row.FIAname**   - TRUE, gets FIA reference name for rowvar, if available (`FIESTA::getRefcodes(rowvar)` for availability).
* **col.FIAname**   - TRUE, gets FIA reference name for colvar, if available (`FIESTA::getRefcodes(rowvar)` for availability).
* **row.orderby**   - Name of variable to order values of rowvar (if row.FIAname=FALSE).
* **col.orderby**   - Name of variable to order values of colvar (if col.FIAname=FALSE).
* **row.add0**      - TRUE, add 0 value in table for row values that occur in `FIESTA::getRefcodes(rowvar)` or in rowlut, but are not in final estimate.
* **col.add0**      - TRUE, add 0 value in table for column values that occur in `FIESTA::getRefcodes(colvar)` or in collut, but are not in final estimate.
* **rowlut**        - A lookup table with variable codes and descriptions to include in rows of output table (See note following for more details).
* **collut**        - A lookup table with specific variable codes and descriptions to include in columns of output table (See note following for more details).
* **rawonly**       - If TRUE, only raw data are returned (this option is more efficient for estimates with many estimation units, rows, and/columns).
* **raw.keep0**     - If TRUE, keeps 0 values in raw data tables. If FALSE, removes 0 values for efficent output.
* **allin1**     - TRUE, table cells include: estimates (% sample error).
* **metric**     - TRUE, output is returned in metric units.
* **estround**   - Number of digits to round estimates to.
* **pseround**   - Number of digits to round percent sample error (pse) to.
* **estnull**    - Number or character to indicate 'not sampled' for estimate.
* **psenull**    - Number or character to indicate 'not sampled' for percent sample error (pse).
* **divideby**   - Conversion of output numbers ('hundred', 'thousand', 'million').


Note: 
rowlut/collut - There are several objectives for including rowlut/collut look-up tables: 1) to include descriptive names that match row/column codes in the input table; 2) to use number codes that match row/column names in the input table for ordering rows; 3) to add rows and/or columns with 0 values for consistency. No duplicate names are allowed.

Include 2 columns in the table: 1-the merging variable with same name as the variable in the input merge table; 2-the ordering or descriptive variable. If the ordering variable is the rowvar/colvar in the input table and the descriptive variable is in rowlut/collut, set row.orderby/col.orderby equal to rowvar/colvar. If the descriptive variable is the rowvar/colvar in the input table, and the ordering code variable is in rowlut/collut, set row.orderby/col.orderby equal to the variable name of the code variable in rowlut/collut. 


<a name="title_opts"></a>
**Title parameters (title_opts)**

If returntitle=TRUE, a default title is generated based on the estimation parameters above. The following parameters allow user-defined inputs for generating customized titles. These parameters are set by supplying a list to the `title_opts` parameter. The possible parameters that can be set within the `title_opts` parameter can be seen by running `help(title_options)`.

* **title.main** - Full title for table.
* **title.ref**  - The ending text for table title. If not NULL, included with title.main.
* **title.rowvar**  - Pretty name for rowvar for table title (If NULL, default = rowvar).
* **title.colvar**  - Pretty name for colvar for table title (If NULL, default = colvar).
* **title.unitvar** - Pretty name for unitvar for table title (If NULL and sumunits=FALSE, default = unitvar).
* **title.estvar**  - Pretty name for estvar for table title (If NULL, default = estvar). For ratio estimates, title.estvarn (default = estvarn) and title.estvard (default = estvard).
* **title.filter**  - Pretty name for any filters for table title.


<a name="savedata_opts"></a>
**Saving data specifications (savedata_opts)**

If savedata=TRUE, output is saved using default settings. The following parameters specify different options for saving output. These parameters are set by supplying a list to the `savedata_opts` parameter. The possible parameters that can be set within the `savedata_opts` parameter can be seen by running `help(savedata_options)`.

* **outfolder**  - Name of folder to output data to (Default = working directory or window to browse).
* **out_fmt**    - Format of output data tables ('sqlite', 'gpkg', 'csv', 'gdb').
* **out_dsn**    - TRUE, data source name of database to output data tables.
* **outfn.pre**  - Add a prefix to output name (e.g., '01_*').
* **outfn.date** - Add date (YYYYMMDD) to output name (e.g., '*_20200220').
* **addtitle**   - TRUE, add title to tables.
* **raw_fmt**    - Format of raw data tables ('sqlite', 'gpkg', 'csv', 'gdb').
* **raw_dsn**    - TRUE, data source name of database to output raw data tables.
* **overwrite_dsn**  - TRUE, overwrites existing data source name database files (e.g., sqlite).
* **overwrite_layer**  - TRUE, overwrites layer within a database or file in outfolder, if exists.
* **append_layer**  - TRUE, appends output to existing layer in database or file in outfolder.


</details>


<a name="required"></a>

## Required variables in input data tables
<details>
  <summary>View Required Variables</summary>


The following variables by data table are required for successful `FIESTA` output.

```{r, results = 'asis', echo=FALSE}

#required.lut <- read.table("C:/_tsf/_GitHub/meta/required_variables.txt", header=TRUE, sep="\t")

required.lut <- data.frame(
  Table = c("tree", "", "cond", "", "", "", "", "", "", "", "", "plot", "", ""), 
  Variable = c("PLT_CN", "TPA_UNADJ", "PLT_CN", "CONDPROP_UNADJ", 
               "COND_STATUS_CD", "NF_COND_STATUS_CD", "SITECLCD", "RESERVCD", "SUBPROP_UNADJ",
               "MICRPROP_UNADJ", "MACRPROP_UNADJ", "CN", "STATECD", "INVYR"), 
  Description = c("popTableIDs - Unique identifier for each plot, for joining tables (e.g. PLT_CN)", 
    "Number of trees per acre each sample tree represents (e.g. DESIGNCD=1: TPA_UNADJ=6.018046 for trees on subplot; 74.965282 for trees on microplot)", "popTableIDs - Unique identifier for each plot, for joining tables (e.g., PLT_CN)", 
    "Unadjusted proportion of condition on each plot. Optional if only 1 condition (record) per plot", 
    "Status of each forested condition on plot (i.e. accessible forest, nonforest, water, etc.)", 
    "Only if ACI=TRUE. Status of each nonforest condition plot (i.e. accessible nonforest, nonsampled nonforest)", 
    "Only if landarea=TIMBERLAND. Measure of site productivity", 
    "If landarea=TIMBERLAND. Reserved status", 
    "Unadjusted proportion of subplot conditions on each plot. Optional if only 1 condition (record) per plot", 
    "If microplot tree attributes. Unadjusted proportion of microplot conditions on each plot. Optional if only 1 condition (record) per plot", 
    "If macroplot tree attributes. Unadjusted proportion of macroplot conditions on each plot. Optional if only 1 condition (record) per plot", 
    "popTableIDs - Unique identifier for each plot, for joining tables (e.g. CN)", 
    "Identifies state each plot is located in. Optional if only 1 state", 
    "Identifies inventory year of each plot. Optional. Assumes estimation time span is less than inventory cycle"), 
    stringsAsFactors = FALSE)

kable(required.lut,
  format = "pandoc",   # default
  # caption = "Title of the table",
  col.names = names(required.lut),
  row.names = FALSE,
  align = c("l"),       # align = c("c", "c", "c", "r")
  # padding = 2         # inner spacing
)
```

</details>


<a name="output"></a>

## Output values from `FIESTA` Green-Book module

Estimates with percent sampling error for the row domain (and column domain) specified by the input parameters. This can be in the form of one table or two separate tables, depending on the number of domains and on allin1 parameter. 

A list object with one or more of the following components. If savedata=TRUE, all output data frames are written to outfolder.

* **$est** - Data frame with estimates by rowvar, colvar (and estimation unit). If sumunits=TRUE or one estimation unit and colvar=NULL, estimates and percent sampling error (confidence level 68%) are all in est. For 95% percent confidence level multiply percent sampling error by 1.96.
* **$pse** - Data frame with percent sampling errors corresponding to est.
* **$raw** - A list of raw data used in the estimation process.
* **$titlelst** - If returntitle=TRUE, a list with one or two titles for est and pse, depending on number of output data frames (see below for list components).



### Raw data used for producing estimates (If rawdata=TRUE, raw$):
<details>
  <summary>View Raw Data</summary>

The raw data includes the domain-level data set used for estimation and separate data frames with calculated variables used in estimation process. The number of processing tables depends on the input parameters. The tables include:

* **raw$domdat**      - Plot domain data used for estimation.
* **raw$unit_totest** - Total by estimation unit 
* **raw$unit_rowest** - If rowvar != NULL, rowvar totals by estimation unit
* **raw$unit_colvar** - If colvar != NULL, colvar totals by estimation unit
* **raw$unit_grpvar** - If colvar != NULL, a combination of rowvar and colvar by estimation unit
* If sumunits=TRUE, the raw data for the summed estimation units are also included: (totest, rowest, colest, grpest, respectively). These tables do not included estimate proportions (nhat and nhat.var). See below for variable descriptions.
* **raw$totest** - Total by estimation unit, summed to population 
* **raw$rowest** - If rowvar != NULL, rowvar totals by estimation unit, summed to population
* **raw$colvar** - If colvar != NULL, colvar totals by estimation unit, summed to population
* **raw$grpvar** - If colvar != NULL, a combination of rowvar and colvar by estimation unit, summed to population 


```{r, results = 'asis', echo=FALSE}
nonratio <- data.frame(Variable = c("nhat", "nhat.var", "est", "est.var"), Description = c("Estimated proportion", "Variance estimate of estimated proportion", "Estimated acres { nhat * ACRES }", "Variance estimate of estimated acres { nhat * ACRES^2 }"), stringsAsFactors = FALSE)

ratio <- data.frame(Variable = c("nhat", "nhat.var", "dhat", "dhat.var", "covar", "estn", "estd", "estn.var", "estn.se", "estn.cv", "estn.pse", "estd.var", "estd.se", "estd.cv", "estd.pse", "est.covar", "rhat", "rhat.var", "rhat.se", "rhat.cv", "est", "est.var"), Description = c("Estimated proportion of land, for numerator", "Variance estimate of estimated proportion of land, for numerator", "Estimated proportion of land, for denominator", "Variance estimate of estimated proportion of land, for denominator", "Covariance of estimated proportion of numerator and denominator", "Estimated acres, for numerator", "Estimated acres, for denominator", "Variance estimate of estimate acres, for numerator", "Standard error estimated acres, for numerator", "Coeffiecient of variation of estimated acres, for numerator", "Percent sampling error of estimate, for numerator", "Variance estimate of estimate acres, for denominator", "Standard error estimated acres, for denominator", "Coefficient of variation of estimated acres, for denominator", "Percent sampling error of estimate, for denominator", "Covariance of estimated acres of numerator and denominator", "Ratio of estimated proportions (numerator/denominator)", "Variance of ratio of estimated proportions", "Standard error of ratio of estimated proportions { rhat.se/rhat }", "Coefficient of variation of ratio of estimated proportions { sqrt(rhat.var) }", "Estimated percent cover of land { rhat*100 }", "Variance of estimated percent cover of land { rhat.var*100^2 }"), stringsAsFactors = FALSE)

all <- data.frame(Variable = c("NBRPLT.gt0", "ACRES", "est.se", "est.cv", "pse", "CI99left", "CI99right", "CI95left", "CI95right", "CI68left", "CI68right"), Description = c("Number of nonzero plots used in estimate", "Total acres for estimation unit", "Standard error of estimated acres { sqrt(est.var) }", "Coefficient of variation of estimated acres { est.se/est }", "Percent sampling error of estimate { est.cv * 100 }", "Left tail of 99% confidence interval for estimate { est - (2.58*est.se) }", "Right tail of 99% confidence interval for estimate { est + (2.58*est.se) }", "Left tail of 95% confidence interval for estimate { est - (1.96*est.se) }", "Right tail of 95% confidence interval for estimate { est + (1.96*est.se) }", "Left tail of 68% confidence interval for estimate { est - (0.97*est.se) }", "Right tail of 68% confidence interval for estimate { est + (0.97*est.se) }"), stringsAsFactors = FALSE)



kable(nonratio,
  format = "pandoc",   # default
  caption = "Description of variables in nonratio tables.",
  col.names = names(nonratio),
  row.names = FALSE,
  align = c("l"),       # align = c("c", "c", "c", "r")
  # padding = 2         # inner spacing
) 


kable(ratio,
  format = "pandoc",   # default
  caption = "Description of variables in nonratio tables.",
  col.names = names(ratio),
  row.names = FALSE,
  align = c("l"),       # align = c("c", "c", "c", "r")
  # padding = 2         # inner spacing
) 


kable(all,
  format = "pandoc",   # default
  caption = "Description of variables in nonratio and ratio tables.",
  col.names = names(all),
  row.names = FALSE,
  align = c("l"),       # align = c("c", "c", "c", "r")
  # padding = 2         # inner spacing
) 

```


</details>

<a name="ref"></a>

## Reference Tables in `FIESTA`
<details>
  <summary>View Reference Tables</summary>

There are several reference tables stored in `FIESTA`, including table variable descriptions, code definitions, and estimation categories. 

* Table variable descriptions - ref_plt, ref_cond, ref_tree
* Code definitions - ref_codes
* Domain variables - ref_domain
* Estimation variables - ref_estvar

getdomain()
getestvar()

</details>


## GB Examples
<a name="GBfun"></a>

### GB Example Data
<details>
  <summary>View GB Example Data</summary>

*Example FIA plot data from FIADB*

The examples use FIA plot data from FIA Evalution 561301, including three inventory years of field measurements in the state of Wyoming, from FIADB_1.7.2.00, last updated June 20, 2018, downloaded on June 25, 2018, and stored as internal data objects in `FIESTA`. 



**Wyoming (WY), Inventory Years 2011-2013 (Evaluation 561301)**

Data Frame  | Description
:-----------| :-----------------------------------------------------------------------------------
WYplt       | WY plot-level data
WYcond      | WY condition-level data
WYtree      | WY tree-level data


*Example Auxiliary data*

Auxiliary data for state-level estimates, including plot-level estimation unit and stratum assignments; area by estimation unit; and pixel counts by strata class and estimation unit, were downloaded from FIADB at the same time, from the same FIA Evaluation (i.e., 561301), and stored as internal data objects in `FIESTA`. Estimates using auxiliary data from FIADB can be compared with EVALIDator estimates, using the 2013 evaluation (https://apps.fs.usda.gov/Evalidator/evalidator.jsp).

Auxiliary data for the custom boundaries are summarized from spatial layers stored as external objects in FIESTA, originating from the USDA Forest Service, Automated Lands Program (ALP; 2018) and from a 250m resolution, Moderate Resolution Imaging Spectroradiometer (MODIS), classified map, reclassified from 3 to 2 classes: 1:forest; 2:nonforest (Ruefenacht et al. 2008)



**Wyoming (WY), Auxiliary data from FIADB (Evaluation 561301)**

Data Frame  | Description
:-----------| :-----------------------------------------------------------------------------------
WYpltassgn  | WY plot-level data with strata and estimation unit assignments
WYunitarea  | WY estimation unit look-up table with total acres by estimation unit (ESTUNIT)
WYstratalut | WY strata look-up table with pixel counts (P1POINTCNT) by strata and estimation unit



**Wyoming (WY), Auxiliary data from other ources**

External data             | Description
:-------------------------| :------------------------------------------------------------------------
WYbighorn_adminbnd.shp    | Polygon shapefile of WY Bighorn National Forest Administrative boundary^1^
WYbighorn_districtbnd.shp | Polygon shapefile of WY Bighorn National Forest District boundaries^2^
WYbighorn_forest_nonforest_250m.tif| GeoTIFF raster of predicted forest/nonforest (1/0)^3^ 

^1^USDA Forest Service, Automated Lands Program (ALP). 2018. S_USA.AdministrativeForest (http://data.fs.usda.gov/geodata/edw). Description: An area encompassing all the National Forest System lands administered by an administrative unit. The area encompasses private lands, other governmental agency lands, and may contain National Forest System lands within the proclaimed boundaries of another administrative unit. All National Forest System lands fall within one and only one Administrative Forest Area.

^2^USDA Forest Service, Automated Lands Program (ALP). 2018. S_USA.RangerDistrict (http://data.fs.usda.gov/geodata/edw). Description: A depiction of the boundary that encompasses a Ranger District.

^3^Based on 250m resolution, Moderate Resolution Imaging Spectroradiometer (MODIS), classified map, reclassified from 3 to 2 classes: 1:forest; 2:nonforest. Projected in Albers Conical Equal Area, Datum NAD27 (Ruefenacht et al. 2008).

</details>


### Set up 

First, you'll need to load the `FIESTA` library:

```{r, warning = F, message = F}
library(FIESTA)
```

Next, you'll need to set up an "outfolder". This is just a file path to a folder where you'd like `FIESTA` to send your data output. For this vignette, we have saved our outfolder file path as the `outfolder` object.

```{r, include = F}
## Set options
options(scipen=6)
options(stringsAsFactors=FALSE)
outfolder <- tempdir()
```


### Get auxiliary data for custom examples

Now, we need to get the auxiliary data for the custom boundaries. The FIESTA *spGetStrata* function is a spatial wrapper function to facilitate extraction and summary of user-defined spatial data used for post-stratification. The function uses the FIESTA *spExtractPoly* and *spExtractRast* functions to subset (i.e., clip) plots to the boundary and extract values from estimation unit (i.e., polygon) and strata values (i.e., raster) to plot center locations, respectively. Other internal spatial functions calculate stratum pixel counts and area by estimation unit. If a polygon strata layer is given, the FIESTA *spPoly2Rast* function converts the polygon layer to raster before calculating strata weights. 

Our custom examples demonstrate how to get data for one area of interest, or population (e.g, Bighorn National Forest) and for one area of interest, with multiple estimation units, or subpopulations (e.g., Bighorn National Forest Districts). 



**Bighorn National Forest**
```{r}

# File names for spatial layers, stored as external data objects in FIESTA. 
WYbhfn <- system.file("extdata", "sp_data/WYbighorn_adminbnd.shp", package="FIESTA")
fornffn <- system.file("extdata", "sp_data/WYbighorn_forest_nonforest_250m.tif", package="FIESTA")


# Get estimation unit and strata information for Bighorn National Forest.
stratdat.bh <- spGetStrata(
      xyplt=WYplt,
      uniqueid="CN", 
      xvar="LON_PUBLIC", 
      yvar="LAT_PUBLIC", 
      prj="longlat", 
      datum="NAD83", 
      unit_layer=WYbhfn, 
      strat_layer=fornffn
      )

## Get names of output list components
names(stratdat.bh)


## Plot assignment of strata and estimation unit (ONEUNIT, STRATUMCD)
head(stratdat.bh$pltassgn)

## Area by estimation unit
stratdat.bh$unitarea

## Pixel counts and strata weights (strwt) by strata and estimation unit
stratdat.bh$stratalut

## Variable names
stratdat.bh$unitvar        # Estimation unit variable
stratdat.bh$strvar         # Strata variable
stratdat.bh$areavar        # Area variable


```


**Bighorn National Forest Districts**
```{r}
# File names for external spatial data 
WYbhdistfn <- system.file("extdata", "sp_data/WYbighorn_districtbnd.shp", package="FIESTA")
WYbhdist.att <- "DISTRICTNA"
fornffn <- system.file("extdata", "sp_data/WYbighorn_forest_nonforest_250m.tif", package="FIESTA")

# Get estimation unit and strata information for Bighorn National Forest Districts
stratdat.bhdist <- spGetStrata(
      xyplt=WYplt,
      uniqueid="CN", 
      xvar="LON_PUBLIC", 
      yvar="LAT_PUBLIC", 
      prj="longlat", 
      datum="NAD83", 
      unit_layer=WYbhdistfn, 
      unitvar=WYbhdist.att,
      strat_layer=fornffn
      )

## Get names of output list components
names(stratdat.bhdist)


## Plot assignment of strata and estimation unit (DISTRICTNA, STRATUMCD)
head(stratdat.bhdist$pltassgn)

## Area by estimation units (Districts)
stratdat.bhdist$unitarea

## Pixel counts and strata weights (strwt) by strata and estimation unit
stratdat.bhdist$stratalut


## Variable names
stratdat.bhdist$unitvar        # Estimation unit variable
stratdat.bhdist$strvar         # Strata variable
stratdat.bhdist$areavar        # Area variable

```


### GB Module
* [modGBpop()](#modGBpop)
* [modGBarea()](#modGBarea)
* [modGBtree()](#modGBtree)
* [modGBratio()](#modGBratio)


<a name="modGBpop"></a>

### modGBpop()

`FIESTA`'s population functions (`mod*pop`) check input data and perform population-level calculations, such as: summing number of sampled plots; adjusting for partial nonresponse; and standardizing auxiliary data. These functions are specific to each `FIESTA` module and are run prior to or within a module for any population of interest. 

For `FIESTA`'s GB Module, the `modGBpop` function calculates and outputs: number of plots, adjustment factors, and an expansion factor by strata. The outputs are similar to data found in FIADB's pop_stratum table. The output from `modGBpop` can be used for one or more estimates from `modGBarea`, `modGBtree`, or `modGBratio` functions.



#### POP1: FIADB POPULATION - Get population data for area and tree estimates for Wyoming, using post-stratification

In this example, we use the sample Wyoming data (2013 Evaluation) stored in `FIESTA` to generate population data for the GB module. We check this output with the FIADB pop_stratum table from FIA DataMart for 561301 Evalid, using the `FIESTA::DBqryCSV` function.
<details>
  <summary>View Example</summary>

```{r, results = FALSE, message = F}
```


```{r, results = FALSE, message = F}
GBpopdat <- modGBpop(
  popTabs = popTables(cond = FIESTA::WYcond,             # FIA plot/condition data
                      tree = FIESTA::WYtree,             # FIA tree data
                      seed = FIESTA::WYseed),            # FIA seedling data
  popTabIDs = popTableIDs(
                      cuniqueid = "PLT_CN"),
  pltassgn = FIESTA::WYpltassgn,  # plot assignments
  pltassgnid = "CN",
  pjoinid = "PLT_CN",             # plot id to join to pltassgn
  unitarea = WYunitarea,          # area by estimation units
  unitvar = "ESTN_UNIT",          # name of estimation unit
  strata = TRUE,                  # if using post-stratification
  strata_opts = strata_options(
    stratalut = WYstratalut)      # strata classes and pixels counts
  )

```

To get the names of the list components associated with the output of our call of `modGBpop`, we run the following code:

```{r, results = T}
names(GBpopdat)
```

From this list outputted by `GBpopdat` we can access many things. Some examples include the number of plots by plot status that can be accessed with the `plotsampcnt` item, the number of conditions by condition status with `condsampcnt`, the strata-level population data, including number of plots and adjustment factors with `stratalut`, and the adjustment factors added to the condition-level, tree-level, and seedling data with `condx`, `treex`, and `seedx`, respectfully. These objects can be seen below:

```{r}
## Look at output from GBpopdat
GBpopdat$plotsampcnt	# Number of plots by plot status
GBpopdat$condsampcnt	# Number of conditions by condition status
# Strata-level population data, including number of plots and adjustment factors
GBpopdat$stratalut  
## Adjustment factors added to condition-level data
GBpopdat$condx
## Adjustment factors added to tree data
GBpopdat$treex
## Adjustment factors added to seedling data
GBpopdat$seedx
```

One may also want to compare `FIESTA` output with FIADB pop_stratum table for WY in the 2013 evaluation to check for consistency. The can be done as follows: 

```{r, results = TRUE}
qry <- "select estn_unit, stratumcd, p1pointcnt, p2pointcnt, expns, 
          adj_factor_macr, adj_factor_subp, adj_factor_micr from pop_stratum 
        where evalid = 561301 order by estn_unit, stratumcd"
pop_stratum <- DBqryCSV(
                  qry, 
                  states="Wyoming",
                  sqltables="pop_stratum"
                  )
head(pop_stratum)
head(GBpopdat$stratalut)
```

</details>


#### POP2: CUSTOM POPULATION - Get population data for area and tree estimates for the Bighorn National Forest, using post-stratification

In this example, we use the sample WY plot data (2013 Evaluation) in FIESTA and output from `spGetStrata` to generate population data for the Bighorn National Forest. Here, we have only one estimation unit within the population of interest (i.e., Bighorn National Forest), therefore strata and pixel counts are summarized to the population.

If the `FIESTA::spGetStrata` function is used to obtain stratification data, the output list object can be input directly into `modGBpop` through the `GBstratdat` parameter. If other methods are used, the data are input through individual parameters.
<details>
  <summary>View Example</summary>

```{r, results = FALSE, message = F}
```



```{r}

## Bighorn National Forest


## Using output list from spGetStrata()
GBpopdat.bh <- modGBpop(
      popTabs=list(plt=WYplt, cond=WYcond, tree=WYtree, seed=WYseed),
      GBstratdat=stratdat.bh)

## Get names of output list components
names(GBpopdat.bh)

## Using output as individual parameter inputs
GBpopdat.bh <- modGBpop(
      popTabs=list(plt=WYplt, cond=WYcond, tree=WYtree, seed=WYseed), 
      pltassgn=stratdat.bh$pltassgn, 
      pltassgnid="CN", 
      unitvar=stratdat.bh$unitvar, 
      unitarea=stratdat.bh$unitarea, 
      areavar=stratdat.bh$areavar, 
      strata=TRUE,
      strata_opts=list(
        stratalut=stratdat.bh$stratalut, 
        strvar=stratdat.bh$strvar, 
        getwt=FALSE)
      )

## Get names of output list components
names(GBpopdat.bh)

## Condition information with adjusted condition proportions for area
head(GBpopdat.bh$condx)

## Tree information with tree-level adjustment factors
head(GBpopdat.bh$treex)

## Seedling information with adjustment factors
head(GBpopdat.bh$seedx)

## Strata-level information, including number of plots by strata and strata-level adjustment factors
GBpopdat.bh$stratalut


```

</details>


</details>


#### POP3: CUSTOM POPULATION - Get population data for area and tree estimates for the Bighorn National Forest Districts, using post-stratification

In this example, we use the sample Wyoming plot data (2013 Evaluation) stored in FIESTA and output from `spGetStrata` to generate population data for Bighorn National Forest Districts. Here, we have more than one estimation unit within the population of interest (i.e., Bighorn National Forest Districts), therefore strata and pixel counts are summarized by each District within the population.

If the `FIESTA::spGetStrata` function is used to obtain stratification data, the output list object can be input directly into `modGBpop` through the `GBstratdat` parameter. If other methods are used, the data are input through individual parameters.
<details>
  <summary>View Example</summary>

```{r, results = FALSE, message = F}
```



```{r}

## Bighorn National Forest District


## Using output list from spGetStrata()
GBpopdat.bhdist <- modGBpop(
      popTabs=list(plt=WYplt, cond=WYcond, tree=WYtree, seed=WYseed), 
      GBstratdat=stratdat.bhdist)

## Get names of output list components
names(GBpopdat.bhdist)


GBpopdat.bhdist <- modGBpop(
      popTabs=list(plt=WYplt, cond=WYcond, tree=WYtree, seed=WYseed), 
      pltassgn=stratdat.bhdist$pltassgn, 
      pltassgnid="CN", 
      unitvar=stratdat.bhdist$unitvar, 
      unitarea=stratdat.bhdist$unitarea, 
      areavar=stratdat.bhdist$areavar, 
      strata_opts=list(
        stratalut=stratdat.bhdist$stratalut, 
        strvar=stratdat.bhdist$strvar, 
        getwt=FALSE)
      )

## Get names of output list components
names(GBpopdat.bhdist)
 
## Condition information with adjusted condition proportions for area
head(GBpopdat.bhdist$condx)

## Tree information with tree-level adjustment factors
head(GBpopdat.bhdist$treex)

## Seedling information with adjustment factors
head(GBpopdat.bhdist$seedx)

## Strata-level information, including number of plots by strata and strata-level adjustment factors
GBpopdat.bhdist$stratalut

```

</details>


<a name="modGBarea()"></a>

### modGBarea()

`FIESTA`'s `modGBarea` function generates acre estimates by domain (e.g., Forest type). Calculations are based on Scott et al. 2015 ('Green-Book') for mapped forest inventory plots. The non-ratio estimator for estimating area by stratum and domain is used. Plots that are totally nonsampled are excluded from the estimation dataset. Next, an adjustment factor is calculated by strata to adjust for nonsampled (nonresponse) conditions that have proportion less than 1. The attribute is the proportion of the plot which is divided by the adjustment factor, and averaged by stratum. Strata means are combined using the strata weights and then expanded to acres using the total land area in the population.

If there are more than one estimation unit (i.e., subpopulation) within the population, estimates are generated by estimation unit. If sumunits=TRUE, the estimates and percent standard errors returned are a sum combination of all estimation units. If rawdata=TRUE, the raw data returned will include estimates by estimation unit.  

Parameters defined in the following examples are organized by category: population data (pop); estimation information (est); and output details (out).

#### POP1a: FIADB POPULATION - Generate Estimate by Estimation Unit and Sum to Population
<details>
  <summary>View Example</summary>

Using the `modGBarea` function we generate estimates by estimation unit (i.e., ESTN_UNIT) and sum to population (i.e., WY). `FIESTA` then returns raw data for area of forest land, Wyoming, 2011-2013 (sum estimation units). Note that we set some options for our table output with the `table_opts` argument. For a full list of possible table options, you can run `help(table_options)`.

The following estimates match output from Evalidator (https://apps.fs.usda.gov/Evalidator/evalidator.jsp) using the WY 2013 Evaluation. 

```{r}
area1a <- modGBarea(
    GBpopdat = GBpopdat,      # pop - population calculations for WY, post-stratification
    landarea = "FOREST",      # est - forest land filter
    sumunits = TRUE,          # est - sum estimation units to population
    )
```

To get the names of the list components associated with the output of our call of `modGBarea`, we run the following code:

```{r, results = T}
names(area1a)
```

To easily access our estimate and percent sampling error of estimate we can just grab the `est` object from out outputted list: 

```{r, results = T}
area1a$est
```

We can also look at raw data and titles for estimate, as shown below:

```{r, results = TRUE}
## Raw data (list object) for estimate
raw1a <- area1a$raw        # extract raw data list object from output
names(raw1a)
head(raw1a$unit_totest)    # estimates by estimation unit (i.e., ESTN_UNIT)
raw1a$totest               # estimates for population (i.e., WY)

```

</details>

#### POP1b: FIADB POPULATION - Adding rows to the estimation output
<details>
  <summary>View Example</summary>

In this example, we look at adding rows to the output and include returntitle=TRUE to return title information.

```{r}
## Area of forest land by forest type, Wyoming, 2011-2013
area1b <- modGBarea(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    rowvar = "FORTYPCD",         # est - row domain
    sumunits = TRUE,             # est - sum estimation units to population
    returntitle = TRUE           # out - return title information
    )
```

Again, we can look at the contents of the output list. The output now includes titlelst, a list of associated titles.

```{r}
names(area1b)
```

And the estimates: 

```{r}
## Estimate and percent sampling error of estimate
area1b$est
```

Along with raw data and titles:

```{r}
## Raw data (list object) for estimate
raw1b <- area1b$raw      # extract raw data list object from output
names(raw1b)
head(raw1b$unit_totest) # estimates by estimation unit (i.e., ESTN_UNIT)
raw1b$totest            # estimates for population (i.e., WY)
head(raw1b$unit_rowest) # estimates by row, by estimation unit (i.e., ESTN_UNIT)
head(raw1b$rowest)      # estimates by row for population (i.e., WY)


## Titles (list object) for estimate
titlelst1b <- area1b$titlelst
names(titlels1bt)
titlelst1b
```

</details>

#### POP1c: FIADB POPULATION - Adding rows and columns to the estimation output
<details>
  <summary>View Example</summary>

In this example, we look at adding rows and columns to output, including FIA names. We also output estimates and percent standard error in the same cell with the `allin1` argument in `table_options` and save data to an outfolder with the `outfolder` argument in `savedata_options`. 

```{r}
## Area of forest land by forest type and stand-size class, Wyoming, 2011-2013
area1c <- modGBarea(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    rowvar = "FORTYPCD",         # est - row domain
    colvar = "STDSZCD",          # est - column domain
    sumunits = TRUE,             # est - sum estimation units to population
    savedata = TRUE,             # out - save data to outfolder
    returntitle = TRUE,          # out - return title information
    table_opts = list(
      row.FIAname = TRUE,          # table - row domain names
      col.FIAname = TRUE,          # table - column domain names
      allin1 = TRUE                # table - return output with est(pse)
      ),
    savedata_opts = list(
      outfolder = outfolder,       # save - outfolder for saving data
      outfn.pre = "WY"             # save - prefix for output files
      )
    )
```

We can again look at the output list, estimates, raw data, and titles:

```{r}
## Look at output list
names(area1c)

## Estimate and percent sampling error of estimate
head(area1c$est)


## Raw data (list object) for estimate
raw1c <- area1c$raw      # extract raw data list object from output
names(raw1c)
head(raw1c$unit_totest) # estimates by estimation unit (i.e., ESTN_UNIT)
head(raw1c$totest)      # estimates for population (i.e., WY)
head(raw1c$unit_rowest) # estimates by row, by estimation unit (i.e., ESTN_UNIT)
head(raw1c$rowest)      # estimates by row for population (i.e., WY)
head(raw1c$unit_colest) # estimates by column, by estimation unit (i.e., ESTN_UNIT)
head(raw1c$colest)      # estimates by column for population (i.e., WY)
head(raw1c$unit_grpest) # estimates by row and column, by estimation unit (i.e., ESTN_UNIT)
head(raw1c$grpest)      # estimates by row and column for population (i.e., WY)


## Titles (list object) for estimate
titlelst1c <- area1c$titlelst
names(titlelst1c)
titlelst1c


## List output files in outfolder
list.files(outfolder, pattern = "WY_area")
list.files(paste0(outfolder, "/rawdata"), pattern = "WY_area")
```


#### POP2a: CUSTOM POPULATION - Generate estimate for Bighorn National Forest
<details>
  <summary>View Example</summary>

Area by forest type and stand-size class, Bighorn National Forest
Note: Since we only have one estimation unit within the population of interest, we set sumunits=FALSE.
  Also, we add ref.title to customize the title outputs.

```{r}
area2a <- modGBarea(
    GBpopdat = GBpopdat.bh,       # pop - population calculations for Bighorn NF, post-stratification
    landarea = "FOREST",          # est - forest land filter
    sumunits = FALSE,             # est - sum estimation units to population
    rowvar = "FORTYPCD",          # est - row domain
    colvar = "STDSZCD",           # est - column domain
    returntitle = TRUE,           # out - return title information
    title_opts = list(
      title.ref = "Bighorn National Forest, 2011-2013"  # title - customize title reference
      ),
    table_opts = list(   
      row.FIAname = TRUE,         # table - return FIA row names
      col.FIAname = TRUE          # table - return FIA column names
      )
    )
```

To get the names of the list components associated with the output of our call of `modGBarea`, we run the following code:

```{r, results = T}
names(area2a)
```

To easily access our estimate and percent sampling error of estimate we can just grab the `est` object from our ouputted list: 

```{r, results = T}
area2a$est
```

We can also look at raw data and titles for estimate, as shown below. Note the change in titles.

```{r, results = TRUE}
## Raw data (list object) for estimate
raw2a <- area2a$raw      # extract raw data list object from output
names(raw2a)
head(raw2a$unit_grpest)  # estimates by row and group domains


## Titles (list object) for estimate
titlelst2a <- area2a$titlelst
names(titlelst2a)
titlelst2a

```

</details>


#### POP2b: CUSTOM POPULATION - Generate estimate for Bighorn National Forest
<details>
  <summary>View Example</summary>

Area by forest type group and primary disturbance class, Bighorn National Forest
Note: Since we only have one estimation unit within the population of interest, we set sumunits=FALSE.
  Let's also add a few more table options to control the forest type groups displayed in the table (rowlut) and fill the NULL values with 0s (estnull).

```{r}

source("C:\\_tsf\\_GitHub\\FIESTA\\R\\table_options.R")
source("C:\\_tsf\\_GitHub\\FIESTA\\R\\datLUTnm.R")
source("C:\\_tsf\\_GitHub\\FIESTA\\R\\Icheck.rowcol.R")
source("C:\\_tsf\\_GitHub\\FIESTA\\R\\Iest.outtabs.R")
source("C:\\_tsf\\_GitHub\\FIESTA\\R\\Itable_functions.R")
source("C:\\_tsf\\_GitHub\\FIESTA\\R\\IGBest.pbar.R")
source("C:\\_tsf\\_GitHub\\FIESTA\\R\\modGBarea.R")

area2b <- modGBarea(
    GBpopdat = GBpopdat.bh,        # pop - population calculations for Bighorn NF, post-stratification
    landarea = "FOREST",           # est - forest land filter
    sumunits = TRUE,               # est - sum estimation units to population
    rowvar = "FORTYPGRPCD",        # est - row domain
    colvar = "DSTRBCD1",           # est - column domain
    returntitle = TRUE,            # out - return title information
    title_opts = list(
      title.ref = "Bighorn National Forest, 2011-2013"  # title - customize title reference
      ),
    table_opts = list(   
      row.FIAname = TRUE,          # table - return FIA row names
      col.FIAname = TRUE,          # table - return FIA column names
      estnull = 0,
      rowlut = c(180, 200, 220, 260, 280, 900, 999),
      raw.keep0 = TRUE
      )
    )

```

To get the names of the list components associated with the output of our call of `modGBarea`, we run the following code:

```{r, results = T}
names(area2b)
```

To easily access our estimate and percent sampling error of estimate we can just grab the `est` object from our ouputted list: 

```{r, results = T}
area2b$est
```

We can also look at raw data and titles for estimate, as shown below. Note the change in titles.

```{r, results = TRUE}
## Raw data (list object) for estimate
raw2b <- area2b$raw      # extract raw data list object from output
names(raw2b)
head(raw2b$unit_grpest)  # estimates by row and group domains


## Titles (list object) for estimate
titlelst2b <- area2b$titlelst
names(titlelst2b)
titlelst2b

```

</details>




#### POP2b: CUSTOM POPULATION - Generate Estimate for Bighorn National Forest
<details>
  <summary>View Example</summary>

Area by forest type group and primary disturbance class, Bighorn National Forest Districts

```{r}
area3a <- modGBarea(
    GBpopdat = GBpopdat.bhdist,    # pop - population calculations for Bighorn NF, post-stratification
    landarea = "FOREST",           # est - forest land filter
    sumunits = TRUE,               # est - sum estimation units to population
    #pcfilter = "DSTRBCD1 > 0",     # est - condition filter for table output
    rowvar = "FORTYPGRPCD",        # est - row domain
    colvar = "DSTRBCD1",           # est - column domain
    returntitle = TRUE,            # out - return title information
    title_opts = list(
      title.ref = "Bighorn National Forest, 2011-2013"  # title - customize title reference
      ),
    table_opts = list(   
      row.FIAname = TRUE,          # table - return FIA row names
      col.FIAname = TRUE           # table - return FIA column names
      )
    )
```

To get the names of the list components associated with the output of our call of `modGBarea`, we run the following code:

```{r, results = T}
names(area2b)
```

To easily access our estimate and percent sampling error of estimate we can just grab the `est` object from our ouputted list: 

```{r, results = T}
area2b$est
```

We can also look at raw data and titles for estimate, as shown below:

```{r, results = TRUE}
## Raw data (list object) for estimate
raw2b <- area2b$raw       # extract raw data list object from output
names(raw2b)
head(raw2b$unit_totest)   # estimates by estimation unit (i.e., ESTN_UNIT)
raw2b$totest              # estimates for population (i.e., WY)


## Titles (list object) for estimate
titlelst2b <- area2b$titlelst
names(titlelst2b)
titlelst2b

```

</details>




</details>

<a name="modGBtree"></a>

### modGBtree

`FIESTA`'s `modGBtree` function generates tree estimates by domain (e.g., Forest type) and/or tree domain (e.g., Species). Calculations are based on Scott et al. 2005 ('the green-book') for mapped forest inventory plots. The non-ratio estimator for estimating tree attributes by stratum and domain is used. Plots that are totally nonsampled are excluded from estimation dataset. Next, an adjustment factor is calculated by strata to adjust for nonsampled (nonresponse) conditions that have proportion less than 1. Attributes adjusted to a per-acre value are summed by plot, divided by the adjustment factor, and averaged by stratum. Strata means are combined using the strata weights and then expanded to using the total land area in the population. 

If there are more than one estimation unit (i.e., subpopulation) within the population, estimates are generated by estimation unit. If `sumunits = TRUE`, the estimates and percent standard errors returned are a sum combination of all estimation units. If `rawdata = TRUE`, the raw data returned will include estimates by estimation unit.  

Parameters defined in the following examples are organized by category: population data (pop); estimation information (est); and output details (out).

The following reference table can be used for defining `estvar` and `estvar.filter`:

```{r}
ref_estvar[, c("ESTTITLE", "ESTVAR", "ESTFILTER", "ESTUNITS")]
```

#### Example 1: Generate Estimates by Estimation Unit and Sum to Population
<details>
  <summary>View Example</summary>

Now, we can generate estimates by estimation unit (i.e., ESTN_UNIT) and sum to population (i.e., WY) with `modGBtree`: 

```{r}
## Return raw data and titles
## Total net cubic-foot volume of live trees (at least 5 inches diameter), Wyoming, 2011-2013 
tree1 <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "VOLCFNET",               # est - net cubic-foot volume
    estvar.filter = "STATUSCD == 1",   # est - live trees only
    returntitle = TRUE           # out - return title information
    )
```

We can now take a look at the output list, estimates and percent sampling errors, raw data, and titles:

```{r}
## Look at output list
names(tree1)

## Estimate and percent sampling error of estimate
tree1$est


## Raw data (list object) for estimate
raw <- tree1$raw      # extract raw data list object from output
names(raw)
head(raw$unit_totest) # estimates by estimation unit (i.e., ESTN_UNIT)
head(raw$totest)      # estimates for population (i.e., WY)


## Titles (list object) for estimate
titlelst <- tree1$titlelst
names(titlelst)
titlelst
```

</details>

#### Example 2: Add Rows to Output
<details>
  <summary>View Example</summary>

This example adds rows to the output for net cubic-foot volume of live trees (at least 5 inches diameter) by forest type, Wyoming, 2011-2013. We also choose to return titles with `returntitle = TRUE`. 

```{r}
tree2 <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "VOLCFNET",               # est - net cubic-foot volume
    estvar.filter = "STATUSCD == 1",   # est - live trees only
    rowvar = "FORTYPCD",         # est - row domain 
    returntitle = TRUE           # out - return title information
    )
```

Again, we investigate the output of the returned list:

```{r}
## Look at output list
names(tree2)

## Estimate and percent sampling error of estimate
tree2$est

## Raw data (list object) for estimate
raw <- tree2$raw      # extract raw data list object from output
names(raw)
head(raw$unit_totest) # estimates by estimation unit (i.e., ESTN_UNIT)
head(raw$totest)      # estimates for population (i.e., WY)
head(raw$unit_rowest) # estimates by row, by estimation unit (i.e., ESTN_UNIT)
head(raw$rowest)      # estimates by row for population (i.e., WY)


## Titles (list object) for estimate
titlelst <- tree2$titlelst
names(titlelst)
titlelst
```

</details>

#### Example 3: Add Rows and Columns to Output
<details>
  <summary>View Example</summary>

This examples adds rows and columns to the output, including FIA names, for net cubic-foot volume of live trees (at least 5 inches diameter) by forest type and stand-size class, Wyoming, 2011-2013. We also use the `*_options` functions to return output with estimates (est) and percent standard error (pse) in same cell - est(pse) with `allin1 = TRUE` and save data to an outfolder with `savedata = TRUE` and `outfolder = outfolder`. 

```{r}
tree3 <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "VOLCFNET",               # est - net cubic-foot volume
    estvar.filter = "STATUSCD  == 1",   # est - live trees only
    rowvar = "FORTYPCD",         # est - row domain
    colvar = "STDSZCD",          # est - column domain
    returntitle = TRUE,          # out - return title information
    savedata = TRUE,             # out - save data to outfolder
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      col.FIAname = TRUE,          # est - column domain names
      allin1 = TRUE                # out - return output with est(pse)
    ),
    savedata_opts = savedata_options(
      outfolder = outfolder,       # out - outfolder for saving data
      outfn.pre = "WY"             # out - prefix for output files
      )
    )
```

Again, we investigate the output of the returned list:

```{r}
## Look at output list from modGBarea()
names(tree3)

## Estimate and percent sampling error of estimate
tree3$est


## Raw data (list object) for estimate
raw <- tree3$raw      # extract raw data list object from output
names(raw)
head(raw$unit_totest) # estimates by estimation unit (i.e., ESTN_UNIT)
head(raw$totest)      # estimates for population (i.e., WY)
head(raw$unit_rowest) # estimates by row, by estimation unit (i.e., ESTN_UNIT)
head(raw$rowest)      # estimates by row for population (i.e., WY)
head(raw$unit_colest) # estimates by column, by estimation unit (i.e., ESTN_UNIT)
head(raw$colest)      # estimates by column for population (i.e., WY)
head(raw$unit_grpest) # estimates by row and column, by estimation unit (i.e., ESTN_UNIT)
head(raw$grpest)      # estimates by row and column for population (i.e., WY)


## Titles (list object) for estimate
titlelst <- tree3$titlelst
names(titlelst)
titlelst


## List output files in outfolder
list.files(outfolder, pattern = "WY_tree")
list.files(paste0(outfolder, "/rawdata"), pattern = "WY_tree")
```

</details>

#### Example 4a: Use Tree Domain in Estimation Output Rows
<details>
  <summary>View Example</summary>

We can use tree domain in estimation output rows:

```{r}
## Number of live trees (at least 1 inch diameter) by species
tree4a <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "TPA_UNADJ",               # est - number of trees per acre 
    estvar.filter = "STATUSCD == 1",    # est - live trees only
    rowvar = "SPCD",             # est - row domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(    
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE               # out - return output with est and pse
      )
    )
```

We can also look at the output list and estimates again:

```{r}
## Look at output list
names(tree4a)

## Estimate and percent sampling error of estimate
tree4a$est
```

</details>

#### Example 4b: Add Seedlings
<details>
  <summary>View Example</summary>

We can also add seedlings. 

Note: seedling data are only available for number of trees (estvar = TPA_UNADJ).

Note: must include seedling data in population data calculations.

```{r}
## Number of live trees by species, including seedlings
tree4b <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    estseed = "add",             # est - add seedling data
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "TPA_UNADJ",               # est - number of trees per acre 
    estvar.filter = "STATUSCD == 1",    # est - live trees only
    rowvar = "SPCD",             # est - row domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE,              # out - return output with est and pse
      )
    )
```

And again we can look at our outputs and compare estimates:

```{r}
## Look at output list
names(tree4b)

## Estimate and percent sampling error of estimate
tree4b$est


## Compare estimates with and without seedlings
head(tree4a$est)
head(tree4b$est)
```

</details>

#### Example 4c: Only Seedlings
<details>
  <summary>View Example</summary>

Of course, we can also look at *only* seedlings.

Note: seedling data are only available for number of trees (estvar = TPA_UNADJ).

Note: must include seedling data in population data calculations.

```{r}
## Number of live trees seedlings by species
tree4c <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    estseed = "only",            # est - add seedling data
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "TPA_UNADJ",        # est - number of trees per acre 
    rowvar = "SPCD",             # est - row domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE               # out - return output with est and pse
      )
    )
```

And again we can look at our outputs and compare estimates:

```{r}
## Look at output list
names(tree4c)

## Estimate and percent sampling error of estimate
tree4c$est

## Compare estimates with, without, and only seedlings
head(tree4a$est)
head(tree4b$est)
head(tree4c$est)
```

</details>

#### Example 5: Use Tree Domain in Estimation Output Columns
<details>
  <summary>View Example</summary>

We can also use tree domain in estimation output columns:

```{r}
## First, we can save our table options for the next few examples
tab_opts <- table_options(
      row.FIAname = TRUE,          # est - row domain names
      col.FIAname = TRUE,          # est - column domain names
      allin1 = TRUE                # out - return output with est(pse)
      )

## Number of live trees (at least 1 inch diameter) by forest type and species
tree5 <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "TPA_UNADJ",               # est - number of trees per acre 
    estvar.filter = "STATUSCD == 1",    # est - live trees only
    rowvar = "FORTYPCD",         # est - row domain
    colvar = "SPCD",             # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = tab_opts
    )
```

And we can see our output:

```{r}
## Look at output list
names(tree5)

## Estimate and percent sampling error of estimate
head(tree5$est)
```

</details>

#### Example 6: Examine Dead Trees with a Filter
<details>
  <summary>View Example</summary>

We can also examine dead trees with the filter `estvar.filter = "STATUSCD == 2 & STANDING_DEAD_CD == 1"`. 

```{r}
## Net cubic-foot volume of dead trees (at least 5 inches diameter) by species and cause of death, 
##    Wyoming, 2011-2013
tree6 <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "VOLCFNET",         # est - number of trees per acre 
    estvar.filter = "STATUSCD == 2 & STANDING_DEAD_CD == 1",    # est - standing dead trees only
    rowvar = "SPCD",             # est - row domain
    colvar = "AGENTCD",          # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = tab_opts
    )
```

And we can see our output of dead trees:

```{r}
## Look at output list
names(tree6)

## Estimate and percent sampling error of estimate
head(tree6$est)
```

</details>

#### Adding diameter classes to population tree data (for `modGBtree` and `modGBratio` examples 7-9)
<details>
  <summary>View Example</summary>

```{r}
## Look at tree data in GBpopdat
head(GBpopdat$treex)

## Use reference data frame stored as an R object in FIESTA
head(ref_diacl2in)

## Appends a new column to GBpopdat$treex classifying the DIA variable based on MIN and MAX columns in ref_diacl2in
dat <- datLUTclass(x = GBpopdat$treex, xvar = "DIA", LUT = ref_diacl2in, LUTclassnm = "DIACL2IN")
GBpopdat$treex <- dat$xLUT

## Look at tree data, with new column (DIACL2IN)  
head(GBpopdat$treex)

## Look at table of new diameter classes (DIACL2IN)
table(GBpopdat$treex$DIACL2IN)



## Another way to append diameter classes
## First, create a new variable using cut function to define 4 diameter classes
dat <- datLUTclass(x = GBpopdat$treex, xvar = "DIA", cutbreaks = c(0, 5, 10, 20, 100))
GBpopdat$treex <- dat$xLUT

## Look at tree data, with new column (DIACL2IN)  
head(GBpopdat$treex)

## Look at table of new diameter classes (DIACL)
table(GBpopdat$treex$DIACL)
```

</details>

#### Example 7: Number of Live Trees by Species Groups and Diameter Class
<details>
  <summary>View Example</summary>

We can also look at the number of live trees by species group and diameter class (DIACL2IN):

```{r}
## not sure why this isn't working -- might want to check in w/ Tracey
## Number of live trees by species group and diameter class (DIACL2IN)
tree7 <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "TPA_UNADJ",               # est - number of trees per acre 
    estvar.filter = "STATUSCD == 1",    # est - live trees only
    rowvar = "SPGRPCD",          # est - row domain
    colvar = "DIACL2IN",         # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = TRUE                # out - return output with est(pse)
      )
    )
```

Outputs:

```{r}
## Look at output list
names(tree7)

## Estimate and percent sampling error of estimate
head(tree7$est)

```

</details>

#### Example 8: Number of Live Trees by Species Groups and a Different Diameter Class
<details>
  <summary>View Example</summary>

Next, we can look at number of live trees by species group and diameter class (DIACL):

```{r}
## not sure why this isn't working -- might want to check in w/ Tracey
## Number of live trees by species group and diameter class (DIACL)
tree8 <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "TPA_UNADJ",               # est - number of trees per acre 
    estvar.filter = "STATUSCD == 1",    # est - live trees only
    rowvar = "SPGRPCD",          # est - row domain
    colvar = "DIACL",            # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = TRUE                # out - return output with est(pse)
      )
    )
```

Outputs:

```{r}
## Look at output list
names(tree8)

## Estimate and percent sampling error of estimate
head(tree8$est)
```

</details>

#### Example 9: Add Seedlings
<details>
  <summary>View Example</summary>

Finally, we add seedlings to Example 8:

```{r}
## again -- not working -- check with tracey
## Number of live trees by species group and diameter class (DIACL), add seedlings
tree9 <- modGBtree(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    estseed = "add",             # est - add seedling data
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "TPA_UNADJ",               # est - number of trees per acre 
    estvar.filter = "STATUSCD == 1",    # est - live trees only
    rowvar = "SPGRPCD",          # est - row domain
    colvar = "DIACL",            # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = TRUE                # out - return output with est(pse)
      )
    )
```

And look at the outputs:

```{r}
## Look at output list
names(tree9)

## Estimate and percent sampling error of estimate
head(tree9$est)
```

</details>

<a name="modGBratio"></a>

### modGBratio

`FIESTA`'s `modGBratio` function generates per-acre and per-tree estimates by domain and/or tree domain by domain (e.g., Forest type) and/or tree domain (e.g., Species). Calculations are based on Scott et al. 2005 ('the green-book') for mapped forest inventory plots. The ratio estimator for estimating per-acre or per-tree by stratum and domain is used, referred to as Ratio of Means (ROM). 

If there are more than one estimation unit (i.e., subpopulation) within the population, estimates are generated by estimation unit. If sumunits = TRUE, the estimates and percent standard errors returned are a sum combination of all estimation units. If rawdata = TRUE, the raw data returned will include estimates by estimation unit.  

Parameters defined in the following examples are organized by category: population data (pop); estimation information (est); and output details (out).

#### Example 1: Generate Estimates by Estimation Unit and Sum to Population
<details>
  <summary>View Example</summary>

We generate estimates by estimation unit (i.e., ESTN_UNIT) and sum to population (i.e., WY):

```{r}
## Return raw data and titles
## Total net cubic-foot volume of live trees (at least 5 inches diameter), Wyoming, 2011-2013 
ratio1 <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "VOLCFNET",               # est - net cubic-foot volume, numerator
    estvarn.filter = "STATUSCD == 1",   # est - live trees only, numerator
    returntitle = TRUE           # out - return title information
    )
```

And we can look at our output:

```{r}
## Look at output list
names(ratio1)

## Estimate and percent sampling error of estimate
head(ratio1$est)


## Raw data (list object) for estimate
raw <- ratio1$raw      # extract raw data list object from output
names(raw)
head(raw$unit_totest) # estimates by estimation unit (i.e., ESTN_UNIT)
head(raw$totest)      # estimates for population (i.e., WY)


## Titles (list object) for estimate
titlelst <- ratio1$titlelst
names(titlelst)
titlelst
```

</details>

#### Example 2: Add Rows
<details>
  <summary>View Example</summary>

We can also add rows to the output:

```{r}
## Net cubic-foot volume of live trees (at least 5 inches diameter) by forest type, Wyoming, 2011-2013
## Return raw data and titles
ratio2 <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "VOLCFNET",               # est - net cubic-foot volume
    estvarn.filter = "STATUSCD == 1",   # est - live trees only
    rowvar = "FORTYPCD",         # est - row domain 
    returntitle = TRUE           # out - return title information
    )
```

And of course view our outputs:

```{r}
## Look at output list
names(ratio2)

## Estimate and percent sampling error of estimate
head(ratio2$est)


## Raw data (list object) for estimate
raw <- ratio2$raw      # extract raw data list object from output
names(raw)
head(raw$unit_totest) # estimates by estimation unit (i.e., ESTN_UNIT)
head(raw$totest)      # estimates for population (i.e., WY)
head(raw$unit_rowest) # estimates by row, by estimation unit (i.e., ESTN_UNIT)
head(raw$rowest)      # estimates by row for population (i.e., WY)


## Titles (list object) for estimate
titlelst <- ratio2$titlelst
names(titlelst)
titlelst
```

</details>

#### Example 3: Add Rows and Columns
<details>
  <summary>View Example</summary>

We can also add row and columns to output, including FIA names:

```{r}
## Return output with estimates (est) and percent standard error (pse) in same cell - est(pse)
## Save data to outfolder:
## Net cubic-foot volume of live trees (at least 5 inches diameter) by forest type and stand-size class, 
##    Wyoming, 2011-2013
ratio3 <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "VOLCFNET",               # est - net cubic-foot volume, numerator
    estvarn.filter = "STATUSCD == 1",   # est - live trees only, numerator
    rowvar = "FORTYPCD",         # est - row domain
    colvar = "STDSZCD",          # est - column domain
    returntitle = TRUE,          # out - return title information
    savedata = TRUE,             # out - save data to outfolder
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      col.FIAname = TRUE,          # est - column domain names
      allin1 = TRUE                # out - return output with est(pse)
      ),
    savedata_opts = savedata_options(
      outfolder = outfolder,       # out - outfolder for saving data
      outfn.pre = "WY"             # out - prefix for output files
      )
    )
```

And look at our output again:

```{r}
## Look at output list from modGBarea()
names(ratio3)

## Estimate and percent sampling error of estimate
head(ratio3$est)


## Raw data (list object) for estimate
raw <- ratio3$raw      # extract raw data list object from output
names(raw)
head(raw$unit_totest) # estimates by estimation unit (i.e., ESTN_UNIT)
head(raw$totest)      # estimates for population (i.e., WY)
head(raw$unit_rowest) # estimates by row, by estimation unit (i.e., ESTN_UNIT)
head(raw$rowest)      # estimates by row for population (i.e., WY)
head(raw$unit_colest) # estimates by column, by estimation unit (i.e., ESTN_UNIT)
head(raw$colest)      # estimates by column for population (i.e., WY)
head(raw$unit_grpest) # estimates by row and column, by estimation unit (i.e., ESTN_UNIT)
head(raw$grpest)      # estimates by row and column for population (i.e., WY)


## Titles (list object) for estimate
titlelst <- ratio3$titlelst
names(titlelst)
titlelst


## List output files in outfolder
list.files(outfolder, pattern = "WY_ratio")
list.files(paste0(outfolder, "/rawdata"), pattern = "WY_ratio")
```

</details>

#### Example 4a: Use Tree Domain in Estimation Output Rows
<details>
  <summary>View Example</summary>

We can also use tree domain in estimation output rows:

```{r}
## Number of live trees (at least 1 inch diameter) by species
ratio4a <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "TPA_UNADJ",               # est - number of trees per acre, numerator 
    estvarn.filter = "STATUSCD == 1",    # est - live trees only, numerator
    rowvar = "SPCD",             # est - row domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE,              # out - return output with est and pse
      )
    )
```

And we can look at our output:

```{r}
## Look at output list
names(ratio4a)

## Estimate and percent sampling error of estimate
head(ratio4a$est)
```

</details>

#### Example 4b: Add Seedlings
<details>
  <summary>View Example</summary>

Now, we can add seedlings. 

Note: seedling data are only available for number of trees (`estvarn = TPA_UNADJ`).

Note: must include seedling data in population data calculations.

```{r}
## Number of live trees by species, including seedlings
ratio4b <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    estseed = "add",             # est - add seedling data
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "TPA_UNADJ",               # est - number of trees per acre, numerator 
    estvarn.filter = "STATUSCD == 1",    # est - live trees only, numerator
    rowvar = "SPCD",             # est - row domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE               # out - return output with est and pse
      )
    )
```

Output and comparison:

```{r}
## Look at output list
names(ratio4b)

## Estimate and percent sampling error of estimate
head(ratio4b$est)

## Compare estimates with and without seedlings
head(ratio4a$est)
head(ratio4b$est)
```

</details>

#### Example 4c: Only Seedlings
<details>
  <summary>View Example</summary>

We could also consider only seedlings.

Note: seedling data are only available for number of trees (`estvarn = TPA_UNADJ`).

Note: must include seedling data in population data calculations.

```{r}
## Number of live seedlings by species
ratio4c <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    estseed = "only",            # est - add seedling data
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "TPA_UNADJ",       # est - number of trees per acre, numerator 
    rowvar = "SPCD",             # est - row domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE               # out - return output with est and pse
      )
    )
```

Output and comparisons:

```{r}
## Look at output list
names(ratio4c)

## Estimate and percent sampling error of estimate
head(ratio4c$est)

## Compare estimates with, without, and only seedlings
head(ratio4a$est)
head(ratio4b$est)
head(ratio4c$est)
```

</details>

#### Example 5: Use Tree Domain in Estimation Output Columns
<details>
  <summary>View Example</summary>

We can also use tree domain in estimation output columns:

```{r}
## Number of live trees (at least 1 inch diameter) by forest type and species
ratio5 <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "TPA_UNADJ",               # est - number of trees per acre, numerator 
    estvarn.filter = "STATUSCD == 1",    # est - live trees only, numerator
    rowvar = "FORTYPCD",         # est - row domain
    colvar = "SPCD",             # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      col.FIAname = TRUE,          # est - column domain names
      allin1 = TRUE                # out - return output with est(pse)
      )
    )
```

And view our output:

```{r}
## Look at output list
names(ratio5)

## Estimate and percent sampling error of estimate
head(ratio5$est)
```

</details>

#### Example 6: Dead Trees
<details>
  <summary>View Example</summary>

Next, we look at dead trees: 

```{r}
## Net cubic-foot volume of dead trees (at least 5 inches diameter) by species and cause of death, 
##    Wyoming, 2011-2013
ratio6 <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "VOLCFNET",         # est - number of trees per acre, numerator 
    estvarn.filter = "STATUSCD == 2 & STANDING_DEAD_CD == 1",    # est - standing dead trees only, numerator
    rowvar = "SPCD",             # est - row domain
    colvar = "AGENTCD",          # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      col.FIAname = TRUE,          # est - column domain names
      allin1 = TRUE                # out - return output with est(pse)
      )
    )
```

And we can see our output:

```{r}
## Look at output list
names(ratio6)

## Estimate and percent sampling error of estimate
head(ratio6$est)
```

</details>

#### Example 7: Tree Domain in Estimation Output Rows and Columns
<details>
  <summary>View Example</summary>

We can also use tree domain in estimation output rows and columns:

```{r}
## Number of live trees by species group and diameter class (DIACL2IN)
ratio7 <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "TPA_UNADJ",               # est - number of trees per acre, numerator 
    estvarn.filter = "STATUSCD == 1",    # est - live trees only, numerator
    rowvar = "SPGRPCD",          # est - row domain
    colvar = "DIACL2IN",         # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = TRUE,               # out - return output with est(pse)
      )
    )
```

And examine our output:

```{r}
## Look at output list
names(ratio7)

## Estimate and percent sampling error of estimate
head(ratio7$est)
```

</details>

#### Example 8: Number of Live Trees by Species Group and Diameter Class
<details>
  <summary>View Example</summary>

Next, we can look at the number of live trees by species group and diameter class (`DIACL`):

```{r}
ratio8 <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "TPA_UNADJ",               # est - number of trees per acre, numerator 
    estvarn.filter = "STATUSCD == 1",    # est - live trees only, numerator
    rowvar = "SPGRPCD",          # est - row domain
    colvar = "DIACL",            # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = TRUE,               # out - return output with est(pse)
      )
    )
```

And of course examine our output:

```{r}
## Look at output list
names(ratio8)

## Estimate and percent sampling error of estimate
head(ratio8$est)
```

</details>

#### Example 9: Number of Live Trees by Species Groups and Diameter Class, and Add Seedlings
<details>
  <summary>View Example</summary>

Now, we look at the number of live trees by species group and diameter class (`DIACL`), and add seedlings:

```{r}
ratio9 <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    estseed = "add",             # est - add seedling data
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "TPA_UNADJ",               # est - number of trees per acre, numerator 
    estvarn.filter = "STATUSCD == 1",    # est - live trees only
    rowvar = "SPGRPCD",          # est - row domain
    colvar = "DIACL",            # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = TRUE,               # out - return output with est(pse)
      )
    )
```

And we again look at our output:

```{r}
## Look at output list
names(ratio9)

## Estimate and percent sampling error of estimate
head(ratio9$est)
```

</details>

#### Example 10: Tree Ratios
<details>
  <summary>View Example</summary>

Next, we look at tree ratios:

```{r}
## Net cubic-foot volume of live trees (at least 5 inches diameter) divided by net cubic-foot volume of all trees 
##    by forest type, Wyoming, 2011-2013
ratio10 <- modGBratio(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    estseed = "add",             # est - add seedling data
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "VOLCFNET",                # est - net cubic-foot volume, numerator
    estvarn.filter = "STATUSCD == 1",    # est - live trees only
    estvard = "VOLCFNET",                # est - net cubic-foot volume, numerator
    rowvar = "FORTYPCD",         # est - row domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = TRUE,               # out - return output with est(pse)
      )
    )
```

And examine the output:

```{r}
## Look at output list
names(ratio10)

## Estimate and percent sampling error of estimate
head(ratio10$est)
```

</details>

### No strata

If you want to exclude post-stratification (i.e., simple random sample, Horvitz-Thompson), you must generate a new population dataset using the `modGBpop` function by setting `strata = FALSE`.

<details>
  <summary>View Code</summary>

```{r}
## Get population data for Wyoming estimates, with no post-stratification
GBpopdat.strat <- modGBpop(
  popTabs = popTables(
    cond = WYcond,               # FIA plot/condition data
    tree = WYtree,               # FIA tree data
    seed = WYtree,               # FIA seedling data
    pltassgn = WYpltassgn),       # plot assignments
    popTabIDs = popTableIDs(pltassgnid = "CN"),             # uniqueid of plots
    unitarea = WYunitarea,       # area by estimation units
    unitvar = "ESTN_UNIT",       # name of estimation unit
    strata = TRUE,               # if using post-stratification
    strata_opts = strata_options(
      stratalut = WYstratalut)   # strata classes and pixels counts
    )


## Get population data for Wyoming estimates, with no post-stratification
GBpopdat.nostrat <- modGBpop(
    popTabs = popTables(
    cond = WYcond,               # FIA plot/condition data
    tree = WYtree,               # FIA tree data
    seed = WYtree,               # FIA seedling data
    pltassgn = WYpltassgn),       # plot assignments
    popTabIDs = popTableIDs(pltassgnid = "CN"),             # uniqueid of plots
    unitarea = WYunitarea,       # area by estimation units
    unitvar = "ESTN_UNIT",       # name of estimation unit
    strata = FALSE               # if using post-stratification
    )
```

```{r}
## Area of forest land by forest type and stand-size class, Wyoming, 2011-2013, with post-stratification
area.strat <- modGBarea( 
    GBpopdat = GBpopdat.strat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    rowvar = "FORTYPCD",         # est - row domain
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE                # out - return output with est(pse)
      )
    )   

## Area of forest land by forest type and stand-size class, Wyoming, 2011-2013, no post-stratification
area.nostrat <- modGBarea( 
    GBpopdat = GBpopdat.nostrat, # pop - population calculations for WY, no post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    rowvar = "FORTYPCD",         # est - row domain
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE                # out - return output with est(pse)
      )
    )   
```

```{r}
## Compare estimates and percent standard errors with and without post-stratification
head(area.strat$est)
head(area.nostrat$est)
```

```{r}
## Number of live trees by species, Wyoming, 2011-2013, with post-stratification
tree.strat <- modGBtree( 
    GBpopdat = GBpopdat.strat,   # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "TPA_UNADJ",               # est - number of trees per acre, numerator 
    estvar.filter = "STATUSCD == 1",    # est - live trees only, numerator
    rowvar = "FORTYPCD",         # est - row domain
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE                # out - return output with est(pse)
      )
    )   

## Number of live trees by species, Wyoming, 2011-2013, no post-stratification
tree.nostrat <- modGBtree( 
    GBpopdat = GBpopdat.nostrat, # pop - population calculations for WY, no post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvar = "TPA_UNADJ",               # est - number of trees per acre, numerator 
    estvar.filter = "STATUSCD == 1",    # est - live trees only, numerator
    rowvar = "FORTYPCD",         # est - row domain
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE                # out - return output with est(pse)
      )
    )   
```

```{r}
## Compare estimates and percent standard errors with and without post-stratification
head(tree.strat$est)
head(tree.nostrat$est)
```

```{r}
## Number of live trees per acre by species, Wyoming, 2011-2013, with post-stratification
ratio.strat <- modGBratio( 
    GBpopdat = GBpopdat.strat,   # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "TPA_UNADJ",               # est - number of trees per acre, numerator 
    estvarn.filter = "STATUSCD == 1",    # est - live trees only, numerator
    rowvar = "FORTYPCD",         # est - row domain
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE                # out - return output with est(pse)
      )
    )   

## Number of live trees per acre by species, Wyoming, 2011-2013, no post-stratification
ratio.nostrat <- modGBratio( 
    GBpopdat = GBpopdat.nostrat, # pop - population calculations for WY, no post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = TRUE,             # est - sum estimation units to population
    estvarn = "TPA_UNADJ",               # est - number of trees per acre, numerator 
    estvarn.filter = "STATUSCD == 1",    # est - live trees only, numerator
    rowvar = "FORTYPCD",         # est - row domain
    table_opts = table_options(
      row.FIAname = TRUE,          # est - row domain names
      allin1 = FALSE                # out - return output with est(pse)
      )
    )  
```

```{r}
## Compare estimates and percent standard errors with and without post-stratification
head(ratio.strat$est)
head(ratio.nostrat$est)
```

</details>

### By estimation unit (`sumunits = FALSE`)

If you just wanted estimates by estimation unit and did not want to sum them, set `sumunits = FALSE`. If `sumunits = FALSE`, the estimates and percent standard errors returned are by estimation unit, with an attribute, named 'unit' appended to data frame, with the unit value. The raw data returned will look the same as if `sumunits = TRUE`. 

<details>
  <summary>View Code</summary>

```{r}
## By estimation unit
## Area of forest land by forest type and stand-size class and Estimation Unit,
##    Wyoming, 2011-2013
##################################################################################
area.unit <- modGBarea(
    GBpopdat = GBpopdat,         # pop - population calculations for WY, post-stratification
    landarea = "FOREST",         # est - forest land filter
    sumunits = FALSE,            # est - sum estimation units to population
    rowvar = "FORTYPCD",         # est - row domain
    colvar = "STDSZCD",          # est - column domain
    returntitle = TRUE,          # out - return title information
    table_opts = table_options(allin1 = TRUE)              # out - return output with est(pse)
    )

## Estimate and percent sampling error of estimate (first 6 rows)
head(area.unit$est)

## Unique estimation units
unique(area.unit$est$unit)
```

</details>

<!-- ### Population data included in estimation module -->

<!-- If you were only interested in a couple estimates for a population, you could calculate population data within a module by including all information directly into the estimation module. The `modGBpop` function is called if the GBpopdat list object is not included as a parameter. -->

<!-- <details> -->
<!--   <summary>View Code</summary> -->

<!-- ```{r} -->
<!-- ## Get population data for Wyoming, with post-stratification -->
<!-- ## Area of forest land by forest type and stand-size class, Wyoming, 2011-2013 -->
<!-- area.strat <- modGBarea(  -->
<!--     cond = WYcond,               # pop - FIA plot/condition data -->
<!--     tree = WYtree,               # pop - FIA tree data -->
<!--     pltassgn = WYpltassgn,       # pop - plot assignments -->
<!--     pltassgnid = "CN",           # pop - uniqueid of plots -->
<!--     unitarea = WYunitarea,       # pop - area by estimation units -->
<!--     unitvar = "ESTN_UNIT",       # pop - name of estimation unit -->
<!--     strata = TRUE,               # pop - if using post-stratification -->
<!--     stratalut = WYstratalut,     # strata classes and pixels counts -->
<!--     landarea = "FOREST",         # est - forest land filter -->
<!--     sumunits = TRUE,             # est - sum estimation units to population -->
<!--     rowvar = "FORTYPCD",         # est - row domain -->
<!--     colvar = "STDSZCD",          # est - column domain -->
<!--     table_opts = table_options(allin1 = TRUE)               # out - return output with est(pse) -->
<!--     )    -->


<!-- ## Get population data for Wyoming, with no post-stratification -->
<!-- ## Area of forest land by forest type and stand-size class, Wyoming, 2011-2013 -->
<!-- area.nostrat <- modGBarea(  -->
<!--     cond = WYcond,               # pop - FIA plot/condition data -->
<!--     tree = WYtree,               # pop - FIA tree data -->
<!--     pltassgn = WYpltassgn,       # pop - plot assignments -->
<!--     pltassgnid = "CN",           # pop - uniqueid of plots -->
<!--     unitarea = WYunitarea,       # pop - area by estimation units -->
<!--     unitvar = "ESTN_UNIT",       # pop - name of estimation unit -->
<!--     strata = FALSE,              # pop - if using post-stratification -->
<!--     landarea = "FOREST",         # est - forest land filter -->
<!--     sumunits = TRUE,             # est - sum estimation units to population -->
<!--     rowvar = "FORTYPCD",         # est - row domain -->
<!--     colvar = "STDSZCD",          # est - column domain -->
<!--     rawdata = TRUE,              # out - return raw data  -->
<!--     allin1 = TRUE                # out - return output with est(pse) -->
<!--     )    -->


<!-- ## Compare estimates and percent standard errors with and without post-stratification -->
<!-- head(area.strat$est) -->
<!-- head(area.nostrat$est) -->
<!-- ``` -->

</details>

## References

Bechtold, William A.; Patterson, Paul L., Editors. 2005. The enhanced Forest Inventory and Analysis program national sampling design and estimation procedures. Gen. Tech. Rep. SRS-80. Asheville, NC: U.S. Department of Agriculture, Forest Service, Southern Research Station. 85 p.

Patterson, Paul L. 2012. Photo-based estimators for the Nevada photo-based inventory. Res. Pap. RMRS-RP-92. Fort Collins, CO: U.S. Department of Agriculture, Forest Service, Rocky Mountain Research Station. 14 p.

Westfall, James A.; Patterson, Paul L.; Coulston, John W. 2011. Post-stratified estimation: with-in strata and total sample size recommendations. Canadian Journal of Forest Research. 41: 1130-1139.

